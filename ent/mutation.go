// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/shopspring/decimal"
	"github.com/skyisboss/pay-system/ent/addres"
	"github.com/skyisboss/pay-system/ent/apprun"
	"github.com/skyisboss/pay-system/ent/balance"
	"github.com/skyisboss/pay-system/ent/blockchain"
	"github.com/skyisboss/pay-system/ent/notify"
	"github.com/skyisboss/pay-system/ent/predicate"
	"github.com/skyisboss/pay-system/ent/product"
	"github.com/skyisboss/pay-system/ent/schema"
	"github.com/skyisboss/pay-system/ent/transfer"
	"github.com/skyisboss/pay-system/ent/tsession"
	"github.com/skyisboss/pay-system/ent/txn"
	"github.com/skyisboss/pay-system/ent/user"
	"github.com/skyisboss/pay-system/ent/withdraw"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAddres     = "Addres"
	TypeApprun     = "Apprun"
	TypeBalance    = "Balance"
	TypeBlockchain = "Blockchain"
	TypeNotify     = "Notify"
	TypeProduct    = "Product"
	TypeTSession   = "TSession"
	TypeTransfer   = "Transfer"
	TypeTxn        = "Txn"
	TypeUser       = "User"
	TypeWithdraw   = "Withdraw"
)

// AddresMutation represents an operation that mutates the Addres nodes in the graph.
type AddresMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	chain_id      *uint64
	addchain_id   *int64
	address       *string
	password      *string
	uuid          *string
	use_to        *int64
	adduse_to     *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Addres, error)
	predicates    []predicate.Addres
}

var _ ent.Mutation = (*AddresMutation)(nil)

// addresOption allows management of the mutation configuration using functional options.
type addresOption func(*AddresMutation)

// newAddresMutation creates new mutation for the Addres entity.
func newAddresMutation(c config, op Op, opts ...addresOption) *AddresMutation {
	m := &AddresMutation{
		config:        c,
		op:            op,
		typ:           TypeAddres,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAddresID sets the ID field of the mutation.
func withAddresID(id uint64) addresOption {
	return func(m *AddresMutation) {
		var (
			err   error
			once  sync.Once
			value *Addres
		)
		m.oldValue = func(ctx context.Context) (*Addres, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Addres.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAddres sets the old Addres of the mutation.
func withAddres(node *Addres) addresOption {
	return func(m *AddresMutation) {
		m.oldValue = func(context.Context) (*Addres, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AddresMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AddresMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Addres entities.
func (m *AddresMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AddresMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AddresMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Addres.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChainID sets the "chain_id" field.
func (m *AddresMutation) SetChainID(u uint64) {
	m.chain_id = &u
	m.addchain_id = nil
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *AddresMutation) ChainID() (r uint64, exists bool) {
	v := m.chain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the Addres entity.
// If the Addres object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddresMutation) OldChainID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// AddChainID adds u to the "chain_id" field.
func (m *AddresMutation) AddChainID(u int64) {
	if m.addchain_id != nil {
		*m.addchain_id += u
	} else {
		m.addchain_id = &u
	}
}

// AddedChainID returns the value that was added to the "chain_id" field in this mutation.
func (m *AddresMutation) AddedChainID() (r int64, exists bool) {
	v := m.addchain_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *AddresMutation) ResetChainID() {
	m.chain_id = nil
	m.addchain_id = nil
}

// SetAddress sets the "address" field.
func (m *AddresMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *AddresMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Addres entity.
// If the Addres object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddresMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *AddresMutation) ResetAddress() {
	m.address = nil
}

// SetPassword sets the "password" field.
func (m *AddresMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AddresMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Addres entity.
// If the Addres object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddresMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AddresMutation) ResetPassword() {
	m.password = nil
}

// SetUUID sets the "uuid" field.
func (m *AddresMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *AddresMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Addres entity.
// If the Addres object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddresMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *AddresMutation) ResetUUID() {
	m.uuid = nil
}

// SetUseTo sets the "use_to" field.
func (m *AddresMutation) SetUseTo(i int64) {
	m.use_to = &i
	m.adduse_to = nil
}

// UseTo returns the value of the "use_to" field in the mutation.
func (m *AddresMutation) UseTo() (r int64, exists bool) {
	v := m.use_to
	if v == nil {
		return
	}
	return *v, true
}

// OldUseTo returns the old "use_to" field's value of the Addres entity.
// If the Addres object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddresMutation) OldUseTo(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseTo: %w", err)
	}
	return oldValue.UseTo, nil
}

// AddUseTo adds i to the "use_to" field.
func (m *AddresMutation) AddUseTo(i int64) {
	if m.adduse_to != nil {
		*m.adduse_to += i
	} else {
		m.adduse_to = &i
	}
}

// AddedUseTo returns the value that was added to the "use_to" field in this mutation.
func (m *AddresMutation) AddedUseTo() (r int64, exists bool) {
	v := m.adduse_to
	if v == nil {
		return
	}
	return *v, true
}

// ResetUseTo resets all changes to the "use_to" field.
func (m *AddresMutation) ResetUseTo() {
	m.use_to = nil
	m.adduse_to = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AddresMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AddresMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Addres entity.
// If the Addres object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddresMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AddresMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[addres.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AddresMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[addres.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AddresMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, addres.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AddresMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AddresMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Addres entity.
// If the Addres object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddresMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AddresMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[addres.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AddresMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[addres.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AddresMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, addres.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AddresMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AddresMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Addres entity.
// If the Addres object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddresMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AddresMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[addres.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AddresMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[addres.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AddresMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, addres.FieldDeletedAt)
}

// Where appends a list predicates to the AddresMutation builder.
func (m *AddresMutation) Where(ps ...predicate.Addres) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AddresMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AddresMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Addres, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AddresMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AddresMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Addres).
func (m *AddresMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AddresMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.chain_id != nil {
		fields = append(fields, addres.FieldChainID)
	}
	if m.address != nil {
		fields = append(fields, addres.FieldAddress)
	}
	if m.password != nil {
		fields = append(fields, addres.FieldPassword)
	}
	if m.uuid != nil {
		fields = append(fields, addres.FieldUUID)
	}
	if m.use_to != nil {
		fields = append(fields, addres.FieldUseTo)
	}
	if m.created_at != nil {
		fields = append(fields, addres.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, addres.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, addres.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AddresMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case addres.FieldChainID:
		return m.ChainID()
	case addres.FieldAddress:
		return m.Address()
	case addres.FieldPassword:
		return m.Password()
	case addres.FieldUUID:
		return m.UUID()
	case addres.FieldUseTo:
		return m.UseTo()
	case addres.FieldCreatedAt:
		return m.CreatedAt()
	case addres.FieldUpdatedAt:
		return m.UpdatedAt()
	case addres.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AddresMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case addres.FieldChainID:
		return m.OldChainID(ctx)
	case addres.FieldAddress:
		return m.OldAddress(ctx)
	case addres.FieldPassword:
		return m.OldPassword(ctx)
	case addres.FieldUUID:
		return m.OldUUID(ctx)
	case addres.FieldUseTo:
		return m.OldUseTo(ctx)
	case addres.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case addres.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case addres.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Addres field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddresMutation) SetField(name string, value ent.Value) error {
	switch name {
	case addres.FieldChainID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	case addres.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case addres.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case addres.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case addres.FieldUseTo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseTo(v)
		return nil
	case addres.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case addres.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case addres.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Addres field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AddresMutation) AddedFields() []string {
	var fields []string
	if m.addchain_id != nil {
		fields = append(fields, addres.FieldChainID)
	}
	if m.adduse_to != nil {
		fields = append(fields, addres.FieldUseTo)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AddresMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case addres.FieldChainID:
		return m.AddedChainID()
	case addres.FieldUseTo:
		return m.AddedUseTo()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddresMutation) AddField(name string, value ent.Value) error {
	switch name {
	case addres.FieldChainID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChainID(v)
		return nil
	case addres.FieldUseTo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUseTo(v)
		return nil
	}
	return fmt.Errorf("unknown Addres numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AddresMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(addres.FieldCreatedAt) {
		fields = append(fields, addres.FieldCreatedAt)
	}
	if m.FieldCleared(addres.FieldUpdatedAt) {
		fields = append(fields, addres.FieldUpdatedAt)
	}
	if m.FieldCleared(addres.FieldDeletedAt) {
		fields = append(fields, addres.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AddresMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AddresMutation) ClearField(name string) error {
	switch name {
	case addres.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case addres.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case addres.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Addres nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AddresMutation) ResetField(name string) error {
	switch name {
	case addres.FieldChainID:
		m.ResetChainID()
		return nil
	case addres.FieldAddress:
		m.ResetAddress()
		return nil
	case addres.FieldPassword:
		m.ResetPassword()
		return nil
	case addres.FieldUUID:
		m.ResetUUID()
		return nil
	case addres.FieldUseTo:
		m.ResetUseTo()
		return nil
	case addres.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case addres.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case addres.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Addres field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AddresMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AddresMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AddresMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AddresMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AddresMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AddresMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AddresMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Addres unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AddresMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Addres edge %s", name)
}

// ApprunMutation represents an operation that mutates the Apprun nodes in the graph.
type ApprunMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	handler       *string
	runing        *uint64
	addruning     *int64
	total         *uint64
	addtotal      *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Apprun, error)
	predicates    []predicate.Apprun
}

var _ ent.Mutation = (*ApprunMutation)(nil)

// apprunOption allows management of the mutation configuration using functional options.
type apprunOption func(*ApprunMutation)

// newApprunMutation creates new mutation for the Apprun entity.
func newApprunMutation(c config, op Op, opts ...apprunOption) *ApprunMutation {
	m := &ApprunMutation{
		config:        c,
		op:            op,
		typ:           TypeApprun,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApprunID sets the ID field of the mutation.
func withApprunID(id uint64) apprunOption {
	return func(m *ApprunMutation) {
		var (
			err   error
			once  sync.Once
			value *Apprun
		)
		m.oldValue = func(ctx context.Context) (*Apprun, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Apprun.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApprun sets the old Apprun of the mutation.
func withApprun(node *Apprun) apprunOption {
	return func(m *ApprunMutation) {
		m.oldValue = func(context.Context) (*Apprun, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApprunMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApprunMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Apprun entities.
func (m *ApprunMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApprunMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApprunMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Apprun.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ApprunMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApprunMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Apprun entity.
// If the Apprun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprunMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ApprunMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[apprun.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ApprunMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[apprun.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApprunMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, apprun.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApprunMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApprunMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Apprun entity.
// If the Apprun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprunMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ApprunMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[apprun.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ApprunMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[apprun.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApprunMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, apprun.FieldUpdatedAt)
}

// SetHandler sets the "handler" field.
func (m *ApprunMutation) SetHandler(s string) {
	m.handler = &s
}

// Handler returns the value of the "handler" field in the mutation.
func (m *ApprunMutation) Handler() (r string, exists bool) {
	v := m.handler
	if v == nil {
		return
	}
	return *v, true
}

// OldHandler returns the old "handler" field's value of the Apprun entity.
// If the Apprun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprunMutation) OldHandler(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandler is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandler requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandler: %w", err)
	}
	return oldValue.Handler, nil
}

// ResetHandler resets all changes to the "handler" field.
func (m *ApprunMutation) ResetHandler() {
	m.handler = nil
}

// SetRuning sets the "runing" field.
func (m *ApprunMutation) SetRuning(u uint64) {
	m.runing = &u
	m.addruning = nil
}

// Runing returns the value of the "runing" field in the mutation.
func (m *ApprunMutation) Runing() (r uint64, exists bool) {
	v := m.runing
	if v == nil {
		return
	}
	return *v, true
}

// OldRuning returns the old "runing" field's value of the Apprun entity.
// If the Apprun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprunMutation) OldRuning(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuning is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuning requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuning: %w", err)
	}
	return oldValue.Runing, nil
}

// AddRuning adds u to the "runing" field.
func (m *ApprunMutation) AddRuning(u int64) {
	if m.addruning != nil {
		*m.addruning += u
	} else {
		m.addruning = &u
	}
}

// AddedRuning returns the value that was added to the "runing" field in this mutation.
func (m *ApprunMutation) AddedRuning() (r int64, exists bool) {
	v := m.addruning
	if v == nil {
		return
	}
	return *v, true
}

// ResetRuning resets all changes to the "runing" field.
func (m *ApprunMutation) ResetRuning() {
	m.runing = nil
	m.addruning = nil
}

// SetTotal sets the "total" field.
func (m *ApprunMutation) SetTotal(u uint64) {
	m.total = &u
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *ApprunMutation) Total() (r uint64, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the Apprun entity.
// If the Apprun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprunMutation) OldTotal(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds u to the "total" field.
func (m *ApprunMutation) AddTotal(u int64) {
	if m.addtotal != nil {
		*m.addtotal += u
	} else {
		m.addtotal = &u
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *ApprunMutation) AddedTotal() (r int64, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotal resets all changes to the "total" field.
func (m *ApprunMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
}

// Where appends a list predicates to the ApprunMutation builder.
func (m *ApprunMutation) Where(ps ...predicate.Apprun) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApprunMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApprunMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Apprun, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApprunMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApprunMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Apprun).
func (m *ApprunMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApprunMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, apprun.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apprun.FieldUpdatedAt)
	}
	if m.handler != nil {
		fields = append(fields, apprun.FieldHandler)
	}
	if m.runing != nil {
		fields = append(fields, apprun.FieldRuning)
	}
	if m.total != nil {
		fields = append(fields, apprun.FieldTotal)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApprunMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apprun.FieldCreatedAt:
		return m.CreatedAt()
	case apprun.FieldUpdatedAt:
		return m.UpdatedAt()
	case apprun.FieldHandler:
		return m.Handler()
	case apprun.FieldRuning:
		return m.Runing()
	case apprun.FieldTotal:
		return m.Total()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApprunMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apprun.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apprun.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apprun.FieldHandler:
		return m.OldHandler(ctx)
	case apprun.FieldRuning:
		return m.OldRuning(ctx)
	case apprun.FieldTotal:
		return m.OldTotal(ctx)
	}
	return nil, fmt.Errorf("unknown Apprun field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApprunMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apprun.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apprun.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apprun.FieldHandler:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandler(v)
		return nil
	case apprun.FieldRuning:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuning(v)
		return nil
	case apprun.FieldTotal:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	}
	return fmt.Errorf("unknown Apprun field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApprunMutation) AddedFields() []string {
	var fields []string
	if m.addruning != nil {
		fields = append(fields, apprun.FieldRuning)
	}
	if m.addtotal != nil {
		fields = append(fields, apprun.FieldTotal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApprunMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apprun.FieldRuning:
		return m.AddedRuning()
	case apprun.FieldTotal:
		return m.AddedTotal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApprunMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apprun.FieldRuning:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRuning(v)
		return nil
	case apprun.FieldTotal:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	}
	return fmt.Errorf("unknown Apprun numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApprunMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apprun.FieldCreatedAt) {
		fields = append(fields, apprun.FieldCreatedAt)
	}
	if m.FieldCleared(apprun.FieldUpdatedAt) {
		fields = append(fields, apprun.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApprunMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApprunMutation) ClearField(name string) error {
	switch name {
	case apprun.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case apprun.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Apprun nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApprunMutation) ResetField(name string) error {
	switch name {
	case apprun.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apprun.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apprun.FieldHandler:
		m.ResetHandler()
		return nil
	case apprun.FieldRuning:
		m.ResetRuning()
		return nil
	case apprun.FieldTotal:
		m.ResetTotal()
		return nil
	}
	return fmt.Errorf("unknown Apprun field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApprunMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApprunMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApprunMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApprunMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApprunMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApprunMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApprunMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Apprun unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApprunMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Apprun edge %s", name)
}

// BalanceMutation represents an operation that mutates the Balance nodes in the graph.
type BalanceMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	chain_id          *uint64
	addchain_id       *int64
	product_id        *uint64
	addproduct_id     *int64
	balance_amount    *decimal.Decimal
	addbalance_amount *decimal.Decimal
	balance_freeze    *decimal.Decimal
	addbalance_freeze *decimal.Decimal
	total_deposit     *decimal.Decimal
	addtotal_deposit  *decimal.Decimal
	total_withdraw    *decimal.Decimal
	addtotal_withdraw *decimal.Decimal
	count_deposit     *uint64
	addcount_deposit  *int64
	count_withdraw    *uint64
	addcount_withdraw *int64
	change_logs       *[]schema.ChangeLogs
	appendchange_logs []schema.ChangeLogs
	version           *int64
	addversion        *int64
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Balance, error)
	predicates        []predicate.Balance
}

var _ ent.Mutation = (*BalanceMutation)(nil)

// balanceOption allows management of the mutation configuration using functional options.
type balanceOption func(*BalanceMutation)

// newBalanceMutation creates new mutation for the Balance entity.
func newBalanceMutation(c config, op Op, opts ...balanceOption) *BalanceMutation {
	m := &BalanceMutation{
		config:        c,
		op:            op,
		typ:           TypeBalance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBalanceID sets the ID field of the mutation.
func withBalanceID(id uint64) balanceOption {
	return func(m *BalanceMutation) {
		var (
			err   error
			once  sync.Once
			value *Balance
		)
		m.oldValue = func(ctx context.Context) (*Balance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Balance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBalance sets the old Balance of the mutation.
func withBalance(node *Balance) balanceOption {
	return func(m *BalanceMutation) {
		m.oldValue = func(context.Context) (*Balance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BalanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BalanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Balance entities.
func (m *BalanceMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BalanceMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BalanceMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Balance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BalanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BalanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Balance entity.
// If the Balance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BalanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BalanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BalanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Balance entity.
// If the Balance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *BalanceMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[balance.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *BalanceMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[balance.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BalanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, balance.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BalanceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BalanceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Balance entity.
// If the Balance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BalanceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[balance.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BalanceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[balance.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BalanceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, balance.FieldDeletedAt)
}

// SetChainID sets the "chain_id" field.
func (m *BalanceMutation) SetChainID(u uint64) {
	m.chain_id = &u
	m.addchain_id = nil
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *BalanceMutation) ChainID() (r uint64, exists bool) {
	v := m.chain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the Balance entity.
// If the Balance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceMutation) OldChainID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// AddChainID adds u to the "chain_id" field.
func (m *BalanceMutation) AddChainID(u int64) {
	if m.addchain_id != nil {
		*m.addchain_id += u
	} else {
		m.addchain_id = &u
	}
}

// AddedChainID returns the value that was added to the "chain_id" field in this mutation.
func (m *BalanceMutation) AddedChainID() (r int64, exists bool) {
	v := m.addchain_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *BalanceMutation) ResetChainID() {
	m.chain_id = nil
	m.addchain_id = nil
}

// SetProductID sets the "product_id" field.
func (m *BalanceMutation) SetProductID(u uint64) {
	m.product_id = &u
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *BalanceMutation) ProductID() (r uint64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the Balance entity.
// If the Balance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceMutation) OldProductID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds u to the "product_id" field.
func (m *BalanceMutation) AddProductID(u int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += u
	} else {
		m.addproduct_id = &u
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *BalanceMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductID resets all changes to the "product_id" field.
func (m *BalanceMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
}

// SetBalanceAmount sets the "balance_amount" field.
func (m *BalanceMutation) SetBalanceAmount(d decimal.Decimal) {
	m.balance_amount = &d
	m.addbalance_amount = nil
}

// BalanceAmount returns the value of the "balance_amount" field in the mutation.
func (m *BalanceMutation) BalanceAmount() (r decimal.Decimal, exists bool) {
	v := m.balance_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldBalanceAmount returns the old "balance_amount" field's value of the Balance entity.
// If the Balance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceMutation) OldBalanceAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalanceAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalanceAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalanceAmount: %w", err)
	}
	return oldValue.BalanceAmount, nil
}

// AddBalanceAmount adds d to the "balance_amount" field.
func (m *BalanceMutation) AddBalanceAmount(d decimal.Decimal) {
	if m.addbalance_amount != nil {
		*m.addbalance_amount = m.addbalance_amount.Add(d)
	} else {
		m.addbalance_amount = &d
	}
}

// AddedBalanceAmount returns the value that was added to the "balance_amount" field in this mutation.
func (m *BalanceMutation) AddedBalanceAmount() (r decimal.Decimal, exists bool) {
	v := m.addbalance_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalanceAmount resets all changes to the "balance_amount" field.
func (m *BalanceMutation) ResetBalanceAmount() {
	m.balance_amount = nil
	m.addbalance_amount = nil
}

// SetBalanceFreeze sets the "balance_freeze" field.
func (m *BalanceMutation) SetBalanceFreeze(d decimal.Decimal) {
	m.balance_freeze = &d
	m.addbalance_freeze = nil
}

// BalanceFreeze returns the value of the "balance_freeze" field in the mutation.
func (m *BalanceMutation) BalanceFreeze() (r decimal.Decimal, exists bool) {
	v := m.balance_freeze
	if v == nil {
		return
	}
	return *v, true
}

// OldBalanceFreeze returns the old "balance_freeze" field's value of the Balance entity.
// If the Balance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceMutation) OldBalanceFreeze(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalanceFreeze is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalanceFreeze requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalanceFreeze: %w", err)
	}
	return oldValue.BalanceFreeze, nil
}

// AddBalanceFreeze adds d to the "balance_freeze" field.
func (m *BalanceMutation) AddBalanceFreeze(d decimal.Decimal) {
	if m.addbalance_freeze != nil {
		*m.addbalance_freeze = m.addbalance_freeze.Add(d)
	} else {
		m.addbalance_freeze = &d
	}
}

// AddedBalanceFreeze returns the value that was added to the "balance_freeze" field in this mutation.
func (m *BalanceMutation) AddedBalanceFreeze() (r decimal.Decimal, exists bool) {
	v := m.addbalance_freeze
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalanceFreeze resets all changes to the "balance_freeze" field.
func (m *BalanceMutation) ResetBalanceFreeze() {
	m.balance_freeze = nil
	m.addbalance_freeze = nil
}

// SetTotalDeposit sets the "total_deposit" field.
func (m *BalanceMutation) SetTotalDeposit(d decimal.Decimal) {
	m.total_deposit = &d
	m.addtotal_deposit = nil
}

// TotalDeposit returns the value of the "total_deposit" field in the mutation.
func (m *BalanceMutation) TotalDeposit() (r decimal.Decimal, exists bool) {
	v := m.total_deposit
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalDeposit returns the old "total_deposit" field's value of the Balance entity.
// If the Balance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceMutation) OldTotalDeposit(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalDeposit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalDeposit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalDeposit: %w", err)
	}
	return oldValue.TotalDeposit, nil
}

// AddTotalDeposit adds d to the "total_deposit" field.
func (m *BalanceMutation) AddTotalDeposit(d decimal.Decimal) {
	if m.addtotal_deposit != nil {
		*m.addtotal_deposit = m.addtotal_deposit.Add(d)
	} else {
		m.addtotal_deposit = &d
	}
}

// AddedTotalDeposit returns the value that was added to the "total_deposit" field in this mutation.
func (m *BalanceMutation) AddedTotalDeposit() (r decimal.Decimal, exists bool) {
	v := m.addtotal_deposit
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalDeposit resets all changes to the "total_deposit" field.
func (m *BalanceMutation) ResetTotalDeposit() {
	m.total_deposit = nil
	m.addtotal_deposit = nil
}

// SetTotalWithdraw sets the "total_withdraw" field.
func (m *BalanceMutation) SetTotalWithdraw(d decimal.Decimal) {
	m.total_withdraw = &d
	m.addtotal_withdraw = nil
}

// TotalWithdraw returns the value of the "total_withdraw" field in the mutation.
func (m *BalanceMutation) TotalWithdraw() (r decimal.Decimal, exists bool) {
	v := m.total_withdraw
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalWithdraw returns the old "total_withdraw" field's value of the Balance entity.
// If the Balance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceMutation) OldTotalWithdraw(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalWithdraw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalWithdraw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalWithdraw: %w", err)
	}
	return oldValue.TotalWithdraw, nil
}

// AddTotalWithdraw adds d to the "total_withdraw" field.
func (m *BalanceMutation) AddTotalWithdraw(d decimal.Decimal) {
	if m.addtotal_withdraw != nil {
		*m.addtotal_withdraw = m.addtotal_withdraw.Add(d)
	} else {
		m.addtotal_withdraw = &d
	}
}

// AddedTotalWithdraw returns the value that was added to the "total_withdraw" field in this mutation.
func (m *BalanceMutation) AddedTotalWithdraw() (r decimal.Decimal, exists bool) {
	v := m.addtotal_withdraw
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalWithdraw resets all changes to the "total_withdraw" field.
func (m *BalanceMutation) ResetTotalWithdraw() {
	m.total_withdraw = nil
	m.addtotal_withdraw = nil
}

// SetCountDeposit sets the "count_deposit" field.
func (m *BalanceMutation) SetCountDeposit(u uint64) {
	m.count_deposit = &u
	m.addcount_deposit = nil
}

// CountDeposit returns the value of the "count_deposit" field in the mutation.
func (m *BalanceMutation) CountDeposit() (r uint64, exists bool) {
	v := m.count_deposit
	if v == nil {
		return
	}
	return *v, true
}

// OldCountDeposit returns the old "count_deposit" field's value of the Balance entity.
// If the Balance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceMutation) OldCountDeposit(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountDeposit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountDeposit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountDeposit: %w", err)
	}
	return oldValue.CountDeposit, nil
}

// AddCountDeposit adds u to the "count_deposit" field.
func (m *BalanceMutation) AddCountDeposit(u int64) {
	if m.addcount_deposit != nil {
		*m.addcount_deposit += u
	} else {
		m.addcount_deposit = &u
	}
}

// AddedCountDeposit returns the value that was added to the "count_deposit" field in this mutation.
func (m *BalanceMutation) AddedCountDeposit() (r int64, exists bool) {
	v := m.addcount_deposit
	if v == nil {
		return
	}
	return *v, true
}

// ResetCountDeposit resets all changes to the "count_deposit" field.
func (m *BalanceMutation) ResetCountDeposit() {
	m.count_deposit = nil
	m.addcount_deposit = nil
}

// SetCountWithdraw sets the "count_withdraw" field.
func (m *BalanceMutation) SetCountWithdraw(u uint64) {
	m.count_withdraw = &u
	m.addcount_withdraw = nil
}

// CountWithdraw returns the value of the "count_withdraw" field in the mutation.
func (m *BalanceMutation) CountWithdraw() (r uint64, exists bool) {
	v := m.count_withdraw
	if v == nil {
		return
	}
	return *v, true
}

// OldCountWithdraw returns the old "count_withdraw" field's value of the Balance entity.
// If the Balance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceMutation) OldCountWithdraw(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountWithdraw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountWithdraw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountWithdraw: %w", err)
	}
	return oldValue.CountWithdraw, nil
}

// AddCountWithdraw adds u to the "count_withdraw" field.
func (m *BalanceMutation) AddCountWithdraw(u int64) {
	if m.addcount_withdraw != nil {
		*m.addcount_withdraw += u
	} else {
		m.addcount_withdraw = &u
	}
}

// AddedCountWithdraw returns the value that was added to the "count_withdraw" field in this mutation.
func (m *BalanceMutation) AddedCountWithdraw() (r int64, exists bool) {
	v := m.addcount_withdraw
	if v == nil {
		return
	}
	return *v, true
}

// ResetCountWithdraw resets all changes to the "count_withdraw" field.
func (m *BalanceMutation) ResetCountWithdraw() {
	m.count_withdraw = nil
	m.addcount_withdraw = nil
}

// SetChangeLogs sets the "change_logs" field.
func (m *BalanceMutation) SetChangeLogs(sl []schema.ChangeLogs) {
	m.change_logs = &sl
	m.appendchange_logs = nil
}

// ChangeLogs returns the value of the "change_logs" field in the mutation.
func (m *BalanceMutation) ChangeLogs() (r []schema.ChangeLogs, exists bool) {
	v := m.change_logs
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeLogs returns the old "change_logs" field's value of the Balance entity.
// If the Balance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceMutation) OldChangeLogs(ctx context.Context) (v []schema.ChangeLogs, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeLogs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeLogs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeLogs: %w", err)
	}
	return oldValue.ChangeLogs, nil
}

// AppendChangeLogs adds sl to the "change_logs" field.
func (m *BalanceMutation) AppendChangeLogs(sl []schema.ChangeLogs) {
	m.appendchange_logs = append(m.appendchange_logs, sl...)
}

// AppendedChangeLogs returns the list of values that were appended to the "change_logs" field in this mutation.
func (m *BalanceMutation) AppendedChangeLogs() ([]schema.ChangeLogs, bool) {
	if len(m.appendchange_logs) == 0 {
		return nil, false
	}
	return m.appendchange_logs, true
}

// ResetChangeLogs resets all changes to the "change_logs" field.
func (m *BalanceMutation) ResetChangeLogs() {
	m.change_logs = nil
	m.appendchange_logs = nil
}

// SetVersion sets the "version" field.
func (m *BalanceMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *BalanceMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Balance entity.
// If the Balance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalanceMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *BalanceMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *BalanceMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *BalanceMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// Where appends a list predicates to the BalanceMutation builder.
func (m *BalanceMutation) Where(ps ...predicate.Balance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BalanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BalanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Balance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BalanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BalanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Balance).
func (m *BalanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BalanceMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, balance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, balance.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, balance.FieldDeletedAt)
	}
	if m.chain_id != nil {
		fields = append(fields, balance.FieldChainID)
	}
	if m.product_id != nil {
		fields = append(fields, balance.FieldProductID)
	}
	if m.balance_amount != nil {
		fields = append(fields, balance.FieldBalanceAmount)
	}
	if m.balance_freeze != nil {
		fields = append(fields, balance.FieldBalanceFreeze)
	}
	if m.total_deposit != nil {
		fields = append(fields, balance.FieldTotalDeposit)
	}
	if m.total_withdraw != nil {
		fields = append(fields, balance.FieldTotalWithdraw)
	}
	if m.count_deposit != nil {
		fields = append(fields, balance.FieldCountDeposit)
	}
	if m.count_withdraw != nil {
		fields = append(fields, balance.FieldCountWithdraw)
	}
	if m.change_logs != nil {
		fields = append(fields, balance.FieldChangeLogs)
	}
	if m.version != nil {
		fields = append(fields, balance.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BalanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case balance.FieldCreatedAt:
		return m.CreatedAt()
	case balance.FieldUpdatedAt:
		return m.UpdatedAt()
	case balance.FieldDeletedAt:
		return m.DeletedAt()
	case balance.FieldChainID:
		return m.ChainID()
	case balance.FieldProductID:
		return m.ProductID()
	case balance.FieldBalanceAmount:
		return m.BalanceAmount()
	case balance.FieldBalanceFreeze:
		return m.BalanceFreeze()
	case balance.FieldTotalDeposit:
		return m.TotalDeposit()
	case balance.FieldTotalWithdraw:
		return m.TotalWithdraw()
	case balance.FieldCountDeposit:
		return m.CountDeposit()
	case balance.FieldCountWithdraw:
		return m.CountWithdraw()
	case balance.FieldChangeLogs:
		return m.ChangeLogs()
	case balance.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BalanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case balance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case balance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case balance.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case balance.FieldChainID:
		return m.OldChainID(ctx)
	case balance.FieldProductID:
		return m.OldProductID(ctx)
	case balance.FieldBalanceAmount:
		return m.OldBalanceAmount(ctx)
	case balance.FieldBalanceFreeze:
		return m.OldBalanceFreeze(ctx)
	case balance.FieldTotalDeposit:
		return m.OldTotalDeposit(ctx)
	case balance.FieldTotalWithdraw:
		return m.OldTotalWithdraw(ctx)
	case balance.FieldCountDeposit:
		return m.OldCountDeposit(ctx)
	case balance.FieldCountWithdraw:
		return m.OldCountWithdraw(ctx)
	case balance.FieldChangeLogs:
		return m.OldChangeLogs(ctx)
	case balance.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown Balance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BalanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case balance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case balance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case balance.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case balance.FieldChainID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	case balance.FieldProductID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case balance.FieldBalanceAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalanceAmount(v)
		return nil
	case balance.FieldBalanceFreeze:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalanceFreeze(v)
		return nil
	case balance.FieldTotalDeposit:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalDeposit(v)
		return nil
	case balance.FieldTotalWithdraw:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalWithdraw(v)
		return nil
	case balance.FieldCountDeposit:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountDeposit(v)
		return nil
	case balance.FieldCountWithdraw:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountWithdraw(v)
		return nil
	case balance.FieldChangeLogs:
		v, ok := value.([]schema.ChangeLogs)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeLogs(v)
		return nil
	case balance.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Balance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BalanceMutation) AddedFields() []string {
	var fields []string
	if m.addchain_id != nil {
		fields = append(fields, balance.FieldChainID)
	}
	if m.addproduct_id != nil {
		fields = append(fields, balance.FieldProductID)
	}
	if m.addbalance_amount != nil {
		fields = append(fields, balance.FieldBalanceAmount)
	}
	if m.addbalance_freeze != nil {
		fields = append(fields, balance.FieldBalanceFreeze)
	}
	if m.addtotal_deposit != nil {
		fields = append(fields, balance.FieldTotalDeposit)
	}
	if m.addtotal_withdraw != nil {
		fields = append(fields, balance.FieldTotalWithdraw)
	}
	if m.addcount_deposit != nil {
		fields = append(fields, balance.FieldCountDeposit)
	}
	if m.addcount_withdraw != nil {
		fields = append(fields, balance.FieldCountWithdraw)
	}
	if m.addversion != nil {
		fields = append(fields, balance.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BalanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case balance.FieldChainID:
		return m.AddedChainID()
	case balance.FieldProductID:
		return m.AddedProductID()
	case balance.FieldBalanceAmount:
		return m.AddedBalanceAmount()
	case balance.FieldBalanceFreeze:
		return m.AddedBalanceFreeze()
	case balance.FieldTotalDeposit:
		return m.AddedTotalDeposit()
	case balance.FieldTotalWithdraw:
		return m.AddedTotalWithdraw()
	case balance.FieldCountDeposit:
		return m.AddedCountDeposit()
	case balance.FieldCountWithdraw:
		return m.AddedCountWithdraw()
	case balance.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BalanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case balance.FieldChainID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChainID(v)
		return nil
	case balance.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case balance.FieldBalanceAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalanceAmount(v)
		return nil
	case balance.FieldBalanceFreeze:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalanceFreeze(v)
		return nil
	case balance.FieldTotalDeposit:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalDeposit(v)
		return nil
	case balance.FieldTotalWithdraw:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalWithdraw(v)
		return nil
	case balance.FieldCountDeposit:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCountDeposit(v)
		return nil
	case balance.FieldCountWithdraw:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCountWithdraw(v)
		return nil
	case balance.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Balance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BalanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(balance.FieldUpdatedAt) {
		fields = append(fields, balance.FieldUpdatedAt)
	}
	if m.FieldCleared(balance.FieldDeletedAt) {
		fields = append(fields, balance.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BalanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BalanceMutation) ClearField(name string) error {
	switch name {
	case balance.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case balance.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Balance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BalanceMutation) ResetField(name string) error {
	switch name {
	case balance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case balance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case balance.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case balance.FieldChainID:
		m.ResetChainID()
		return nil
	case balance.FieldProductID:
		m.ResetProductID()
		return nil
	case balance.FieldBalanceAmount:
		m.ResetBalanceAmount()
		return nil
	case balance.FieldBalanceFreeze:
		m.ResetBalanceFreeze()
		return nil
	case balance.FieldTotalDeposit:
		m.ResetTotalDeposit()
		return nil
	case balance.FieldTotalWithdraw:
		m.ResetTotalWithdraw()
		return nil
	case balance.FieldCountDeposit:
		m.ResetCountDeposit()
		return nil
	case balance.FieldCountWithdraw:
		m.ResetCountWithdraw()
		return nil
	case balance.FieldChangeLogs:
		m.ResetChangeLogs()
		return nil
	case balance.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown Balance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BalanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BalanceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BalanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BalanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BalanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BalanceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BalanceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Balance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BalanceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Balance edge %s", name)
}

// BlockchainMutation represents an operation that mutates the Blockchain nodes in the graph.
type BlockchainMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint64
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	chain                *string
	types                *string
	symbol               *string
	decimals             *int64
	adddecimals          *int64
	status               *int64
	addstatus            *int64
	token_address        *string
	token_abi            *string
	cold_address         *string
	hot_address          *string
	scan_block_num       *int64
	addscan_block_num    *int64
	min_free_num         *int64
	addmin_free_num      *int64
	min_confirm_num      *int64
	addmin_confirm_num   *int64
	withdraw_fee         *float64
	addwithdraw_fee      *float64
	withdraw_fee_type    *int64
	addwithdraw_fee_type *int64
	min_deposit          *decimal.Decimal
	addmin_deposit       *decimal.Decimal
	min_withdraw         *decimal.Decimal
	addmin_withdraw      *decimal.Decimal
	min_collect          *decimal.Decimal
	addmin_collect       *decimal.Decimal
	gas_price            *schema.GasPrice
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*Blockchain, error)
	predicates           []predicate.Blockchain
}

var _ ent.Mutation = (*BlockchainMutation)(nil)

// blockchainOption allows management of the mutation configuration using functional options.
type blockchainOption func(*BlockchainMutation)

// newBlockchainMutation creates new mutation for the Blockchain entity.
func newBlockchainMutation(c config, op Op, opts ...blockchainOption) *BlockchainMutation {
	m := &BlockchainMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockchain,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockchainID sets the ID field of the mutation.
func withBlockchainID(id uint64) blockchainOption {
	return func(m *BlockchainMutation) {
		var (
			err   error
			once  sync.Once
			value *Blockchain
		)
		m.oldValue = func(ctx context.Context) (*Blockchain, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Blockchain.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockchain sets the old Blockchain of the mutation.
func withBlockchain(node *Blockchain) blockchainOption {
	return func(m *BlockchainMutation) {
		m.oldValue = func(context.Context) (*Blockchain, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockchainMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockchainMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Blockchain entities.
func (m *BlockchainMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockchainMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockchainMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Blockchain.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockchainMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockchainMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *BlockchainMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[blockchain.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *BlockchainMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[blockchain.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockchainMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, blockchain.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockchainMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockchainMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *BlockchainMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[blockchain.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *BlockchainMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[blockchain.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockchainMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, blockchain.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BlockchainMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BlockchainMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BlockchainMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[blockchain.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BlockchainMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[blockchain.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BlockchainMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, blockchain.FieldDeletedAt)
}

// SetChain sets the "chain" field.
func (m *BlockchainMutation) SetChain(s string) {
	m.chain = &s
}

// Chain returns the value of the "chain" field in the mutation.
func (m *BlockchainMutation) Chain() (r string, exists bool) {
	v := m.chain
	if v == nil {
		return
	}
	return *v, true
}

// OldChain returns the old "chain" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldChain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChain: %w", err)
	}
	return oldValue.Chain, nil
}

// ResetChain resets all changes to the "chain" field.
func (m *BlockchainMutation) ResetChain() {
	m.chain = nil
}

// SetTypes sets the "types" field.
func (m *BlockchainMutation) SetTypes(s string) {
	m.types = &s
}

// Types returns the value of the "types" field in the mutation.
func (m *BlockchainMutation) Types() (r string, exists bool) {
	v := m.types
	if v == nil {
		return
	}
	return *v, true
}

// OldTypes returns the old "types" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldTypes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypes: %w", err)
	}
	return oldValue.Types, nil
}

// ResetTypes resets all changes to the "types" field.
func (m *BlockchainMutation) ResetTypes() {
	m.types = nil
}

// SetSymbol sets the "symbol" field.
func (m *BlockchainMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *BlockchainMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *BlockchainMutation) ResetSymbol() {
	m.symbol = nil
}

// SetDecimals sets the "decimals" field.
func (m *BlockchainMutation) SetDecimals(i int64) {
	m.decimals = &i
	m.adddecimals = nil
}

// Decimals returns the value of the "decimals" field in the mutation.
func (m *BlockchainMutation) Decimals() (r int64, exists bool) {
	v := m.decimals
	if v == nil {
		return
	}
	return *v, true
}

// OldDecimals returns the old "decimals" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldDecimals(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDecimals is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDecimals requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDecimals: %w", err)
	}
	return oldValue.Decimals, nil
}

// AddDecimals adds i to the "decimals" field.
func (m *BlockchainMutation) AddDecimals(i int64) {
	if m.adddecimals != nil {
		*m.adddecimals += i
	} else {
		m.adddecimals = &i
	}
}

// AddedDecimals returns the value that was added to the "decimals" field in this mutation.
func (m *BlockchainMutation) AddedDecimals() (r int64, exists bool) {
	v := m.adddecimals
	if v == nil {
		return
	}
	return *v, true
}

// ResetDecimals resets all changes to the "decimals" field.
func (m *BlockchainMutation) ResetDecimals() {
	m.decimals = nil
	m.adddecimals = nil
}

// SetStatus sets the "status" field.
func (m *BlockchainMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *BlockchainMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *BlockchainMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *BlockchainMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *BlockchainMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetTokenAddress sets the "token_address" field.
func (m *BlockchainMutation) SetTokenAddress(s string) {
	m.token_address = &s
}

// TokenAddress returns the value of the "token_address" field in the mutation.
func (m *BlockchainMutation) TokenAddress() (r string, exists bool) {
	v := m.token_address
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenAddress returns the old "token_address" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldTokenAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenAddress: %w", err)
	}
	return oldValue.TokenAddress, nil
}

// ResetTokenAddress resets all changes to the "token_address" field.
func (m *BlockchainMutation) ResetTokenAddress() {
	m.token_address = nil
}

// SetTokenAbi sets the "token_abi" field.
func (m *BlockchainMutation) SetTokenAbi(s string) {
	m.token_abi = &s
}

// TokenAbi returns the value of the "token_abi" field in the mutation.
func (m *BlockchainMutation) TokenAbi() (r string, exists bool) {
	v := m.token_abi
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenAbi returns the old "token_abi" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldTokenAbi(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenAbi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenAbi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenAbi: %w", err)
	}
	return oldValue.TokenAbi, nil
}

// ClearTokenAbi clears the value of the "token_abi" field.
func (m *BlockchainMutation) ClearTokenAbi() {
	m.token_abi = nil
	m.clearedFields[blockchain.FieldTokenAbi] = struct{}{}
}

// TokenAbiCleared returns if the "token_abi" field was cleared in this mutation.
func (m *BlockchainMutation) TokenAbiCleared() bool {
	_, ok := m.clearedFields[blockchain.FieldTokenAbi]
	return ok
}

// ResetTokenAbi resets all changes to the "token_abi" field.
func (m *BlockchainMutation) ResetTokenAbi() {
	m.token_abi = nil
	delete(m.clearedFields, blockchain.FieldTokenAbi)
}

// SetColdAddress sets the "cold_address" field.
func (m *BlockchainMutation) SetColdAddress(s string) {
	m.cold_address = &s
}

// ColdAddress returns the value of the "cold_address" field in the mutation.
func (m *BlockchainMutation) ColdAddress() (r string, exists bool) {
	v := m.cold_address
	if v == nil {
		return
	}
	return *v, true
}

// OldColdAddress returns the old "cold_address" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldColdAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColdAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColdAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColdAddress: %w", err)
	}
	return oldValue.ColdAddress, nil
}

// ResetColdAddress resets all changes to the "cold_address" field.
func (m *BlockchainMutation) ResetColdAddress() {
	m.cold_address = nil
}

// SetHotAddress sets the "hot_address" field.
func (m *BlockchainMutation) SetHotAddress(s string) {
	m.hot_address = &s
}

// HotAddress returns the value of the "hot_address" field in the mutation.
func (m *BlockchainMutation) HotAddress() (r string, exists bool) {
	v := m.hot_address
	if v == nil {
		return
	}
	return *v, true
}

// OldHotAddress returns the old "hot_address" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldHotAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHotAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHotAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHotAddress: %w", err)
	}
	return oldValue.HotAddress, nil
}

// ResetHotAddress resets all changes to the "hot_address" field.
func (m *BlockchainMutation) ResetHotAddress() {
	m.hot_address = nil
}

// SetScanBlockNum sets the "scan_block_num" field.
func (m *BlockchainMutation) SetScanBlockNum(i int64) {
	m.scan_block_num = &i
	m.addscan_block_num = nil
}

// ScanBlockNum returns the value of the "scan_block_num" field in the mutation.
func (m *BlockchainMutation) ScanBlockNum() (r int64, exists bool) {
	v := m.scan_block_num
	if v == nil {
		return
	}
	return *v, true
}

// OldScanBlockNum returns the old "scan_block_num" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldScanBlockNum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScanBlockNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScanBlockNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScanBlockNum: %w", err)
	}
	return oldValue.ScanBlockNum, nil
}

// AddScanBlockNum adds i to the "scan_block_num" field.
func (m *BlockchainMutation) AddScanBlockNum(i int64) {
	if m.addscan_block_num != nil {
		*m.addscan_block_num += i
	} else {
		m.addscan_block_num = &i
	}
}

// AddedScanBlockNum returns the value that was added to the "scan_block_num" field in this mutation.
func (m *BlockchainMutation) AddedScanBlockNum() (r int64, exists bool) {
	v := m.addscan_block_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetScanBlockNum resets all changes to the "scan_block_num" field.
func (m *BlockchainMutation) ResetScanBlockNum() {
	m.scan_block_num = nil
	m.addscan_block_num = nil
}

// SetMinFreeNum sets the "min_free_num" field.
func (m *BlockchainMutation) SetMinFreeNum(i int64) {
	m.min_free_num = &i
	m.addmin_free_num = nil
}

// MinFreeNum returns the value of the "min_free_num" field in the mutation.
func (m *BlockchainMutation) MinFreeNum() (r int64, exists bool) {
	v := m.min_free_num
	if v == nil {
		return
	}
	return *v, true
}

// OldMinFreeNum returns the old "min_free_num" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldMinFreeNum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinFreeNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinFreeNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinFreeNum: %w", err)
	}
	return oldValue.MinFreeNum, nil
}

// AddMinFreeNum adds i to the "min_free_num" field.
func (m *BlockchainMutation) AddMinFreeNum(i int64) {
	if m.addmin_free_num != nil {
		*m.addmin_free_num += i
	} else {
		m.addmin_free_num = &i
	}
}

// AddedMinFreeNum returns the value that was added to the "min_free_num" field in this mutation.
func (m *BlockchainMutation) AddedMinFreeNum() (r int64, exists bool) {
	v := m.addmin_free_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinFreeNum resets all changes to the "min_free_num" field.
func (m *BlockchainMutation) ResetMinFreeNum() {
	m.min_free_num = nil
	m.addmin_free_num = nil
}

// SetMinConfirmNum sets the "min_confirm_num" field.
func (m *BlockchainMutation) SetMinConfirmNum(i int64) {
	m.min_confirm_num = &i
	m.addmin_confirm_num = nil
}

// MinConfirmNum returns the value of the "min_confirm_num" field in the mutation.
func (m *BlockchainMutation) MinConfirmNum() (r int64, exists bool) {
	v := m.min_confirm_num
	if v == nil {
		return
	}
	return *v, true
}

// OldMinConfirmNum returns the old "min_confirm_num" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldMinConfirmNum(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinConfirmNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinConfirmNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinConfirmNum: %w", err)
	}
	return oldValue.MinConfirmNum, nil
}

// AddMinConfirmNum adds i to the "min_confirm_num" field.
func (m *BlockchainMutation) AddMinConfirmNum(i int64) {
	if m.addmin_confirm_num != nil {
		*m.addmin_confirm_num += i
	} else {
		m.addmin_confirm_num = &i
	}
}

// AddedMinConfirmNum returns the value that was added to the "min_confirm_num" field in this mutation.
func (m *BlockchainMutation) AddedMinConfirmNum() (r int64, exists bool) {
	v := m.addmin_confirm_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinConfirmNum resets all changes to the "min_confirm_num" field.
func (m *BlockchainMutation) ResetMinConfirmNum() {
	m.min_confirm_num = nil
	m.addmin_confirm_num = nil
}

// SetWithdrawFee sets the "withdraw_fee" field.
func (m *BlockchainMutation) SetWithdrawFee(f float64) {
	m.withdraw_fee = &f
	m.addwithdraw_fee = nil
}

// WithdrawFee returns the value of the "withdraw_fee" field in the mutation.
func (m *BlockchainMutation) WithdrawFee() (r float64, exists bool) {
	v := m.withdraw_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldWithdrawFee returns the old "withdraw_fee" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldWithdrawFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithdrawFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithdrawFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithdrawFee: %w", err)
	}
	return oldValue.WithdrawFee, nil
}

// AddWithdrawFee adds f to the "withdraw_fee" field.
func (m *BlockchainMutation) AddWithdrawFee(f float64) {
	if m.addwithdraw_fee != nil {
		*m.addwithdraw_fee += f
	} else {
		m.addwithdraw_fee = &f
	}
}

// AddedWithdrawFee returns the value that was added to the "withdraw_fee" field in this mutation.
func (m *BlockchainMutation) AddedWithdrawFee() (r float64, exists bool) {
	v := m.addwithdraw_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetWithdrawFee resets all changes to the "withdraw_fee" field.
func (m *BlockchainMutation) ResetWithdrawFee() {
	m.withdraw_fee = nil
	m.addwithdraw_fee = nil
}

// SetWithdrawFeeType sets the "withdraw_fee_type" field.
func (m *BlockchainMutation) SetWithdrawFeeType(i int64) {
	m.withdraw_fee_type = &i
	m.addwithdraw_fee_type = nil
}

// WithdrawFeeType returns the value of the "withdraw_fee_type" field in the mutation.
func (m *BlockchainMutation) WithdrawFeeType() (r int64, exists bool) {
	v := m.withdraw_fee_type
	if v == nil {
		return
	}
	return *v, true
}

// OldWithdrawFeeType returns the old "withdraw_fee_type" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldWithdrawFeeType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithdrawFeeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithdrawFeeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithdrawFeeType: %w", err)
	}
	return oldValue.WithdrawFeeType, nil
}

// AddWithdrawFeeType adds i to the "withdraw_fee_type" field.
func (m *BlockchainMutation) AddWithdrawFeeType(i int64) {
	if m.addwithdraw_fee_type != nil {
		*m.addwithdraw_fee_type += i
	} else {
		m.addwithdraw_fee_type = &i
	}
}

// AddedWithdrawFeeType returns the value that was added to the "withdraw_fee_type" field in this mutation.
func (m *BlockchainMutation) AddedWithdrawFeeType() (r int64, exists bool) {
	v := m.addwithdraw_fee_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetWithdrawFeeType resets all changes to the "withdraw_fee_type" field.
func (m *BlockchainMutation) ResetWithdrawFeeType() {
	m.withdraw_fee_type = nil
	m.addwithdraw_fee_type = nil
}

// SetMinDeposit sets the "min_deposit" field.
func (m *BlockchainMutation) SetMinDeposit(d decimal.Decimal) {
	m.min_deposit = &d
	m.addmin_deposit = nil
}

// MinDeposit returns the value of the "min_deposit" field in the mutation.
func (m *BlockchainMutation) MinDeposit() (r decimal.Decimal, exists bool) {
	v := m.min_deposit
	if v == nil {
		return
	}
	return *v, true
}

// OldMinDeposit returns the old "min_deposit" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldMinDeposit(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinDeposit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinDeposit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinDeposit: %w", err)
	}
	return oldValue.MinDeposit, nil
}

// AddMinDeposit adds d to the "min_deposit" field.
func (m *BlockchainMutation) AddMinDeposit(d decimal.Decimal) {
	if m.addmin_deposit != nil {
		*m.addmin_deposit = m.addmin_deposit.Add(d)
	} else {
		m.addmin_deposit = &d
	}
}

// AddedMinDeposit returns the value that was added to the "min_deposit" field in this mutation.
func (m *BlockchainMutation) AddedMinDeposit() (r decimal.Decimal, exists bool) {
	v := m.addmin_deposit
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinDeposit resets all changes to the "min_deposit" field.
func (m *BlockchainMutation) ResetMinDeposit() {
	m.min_deposit = nil
	m.addmin_deposit = nil
}

// SetMinWithdraw sets the "min_withdraw" field.
func (m *BlockchainMutation) SetMinWithdraw(d decimal.Decimal) {
	m.min_withdraw = &d
	m.addmin_withdraw = nil
}

// MinWithdraw returns the value of the "min_withdraw" field in the mutation.
func (m *BlockchainMutation) MinWithdraw() (r decimal.Decimal, exists bool) {
	v := m.min_withdraw
	if v == nil {
		return
	}
	return *v, true
}

// OldMinWithdraw returns the old "min_withdraw" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldMinWithdraw(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinWithdraw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinWithdraw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinWithdraw: %w", err)
	}
	return oldValue.MinWithdraw, nil
}

// AddMinWithdraw adds d to the "min_withdraw" field.
func (m *BlockchainMutation) AddMinWithdraw(d decimal.Decimal) {
	if m.addmin_withdraw != nil {
		*m.addmin_withdraw = m.addmin_withdraw.Add(d)
	} else {
		m.addmin_withdraw = &d
	}
}

// AddedMinWithdraw returns the value that was added to the "min_withdraw" field in this mutation.
func (m *BlockchainMutation) AddedMinWithdraw() (r decimal.Decimal, exists bool) {
	v := m.addmin_withdraw
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinWithdraw resets all changes to the "min_withdraw" field.
func (m *BlockchainMutation) ResetMinWithdraw() {
	m.min_withdraw = nil
	m.addmin_withdraw = nil
}

// SetMinCollect sets the "min_collect" field.
func (m *BlockchainMutation) SetMinCollect(d decimal.Decimal) {
	m.min_collect = &d
	m.addmin_collect = nil
}

// MinCollect returns the value of the "min_collect" field in the mutation.
func (m *BlockchainMutation) MinCollect() (r decimal.Decimal, exists bool) {
	v := m.min_collect
	if v == nil {
		return
	}
	return *v, true
}

// OldMinCollect returns the old "min_collect" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldMinCollect(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinCollect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinCollect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinCollect: %w", err)
	}
	return oldValue.MinCollect, nil
}

// AddMinCollect adds d to the "min_collect" field.
func (m *BlockchainMutation) AddMinCollect(d decimal.Decimal) {
	if m.addmin_collect != nil {
		*m.addmin_collect = m.addmin_collect.Add(d)
	} else {
		m.addmin_collect = &d
	}
}

// AddedMinCollect returns the value that was added to the "min_collect" field in this mutation.
func (m *BlockchainMutation) AddedMinCollect() (r decimal.Decimal, exists bool) {
	v := m.addmin_collect
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinCollect resets all changes to the "min_collect" field.
func (m *BlockchainMutation) ResetMinCollect() {
	m.min_collect = nil
	m.addmin_collect = nil
}

// SetGasPrice sets the "gas_price" field.
func (m *BlockchainMutation) SetGasPrice(sp schema.GasPrice) {
	m.gas_price = &sp
}

// GasPrice returns the value of the "gas_price" field in the mutation.
func (m *BlockchainMutation) GasPrice() (r schema.GasPrice, exists bool) {
	v := m.gas_price
	if v == nil {
		return
	}
	return *v, true
}

// OldGasPrice returns the old "gas_price" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldGasPrice(ctx context.Context) (v schema.GasPrice, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGasPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGasPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGasPrice: %w", err)
	}
	return oldValue.GasPrice, nil
}

// ClearGasPrice clears the value of the "gas_price" field.
func (m *BlockchainMutation) ClearGasPrice() {
	m.gas_price = nil
	m.clearedFields[blockchain.FieldGasPrice] = struct{}{}
}

// GasPriceCleared returns if the "gas_price" field was cleared in this mutation.
func (m *BlockchainMutation) GasPriceCleared() bool {
	_, ok := m.clearedFields[blockchain.FieldGasPrice]
	return ok
}

// ResetGasPrice resets all changes to the "gas_price" field.
func (m *BlockchainMutation) ResetGasPrice() {
	m.gas_price = nil
	delete(m.clearedFields, blockchain.FieldGasPrice)
}

// Where appends a list predicates to the BlockchainMutation builder.
func (m *BlockchainMutation) Where(ps ...predicate.Blockchain) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockchainMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockchainMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Blockchain, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockchainMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockchainMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Blockchain).
func (m *BlockchainMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockchainMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, blockchain.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blockchain.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, blockchain.FieldDeletedAt)
	}
	if m.chain != nil {
		fields = append(fields, blockchain.FieldChain)
	}
	if m.types != nil {
		fields = append(fields, blockchain.FieldTypes)
	}
	if m.symbol != nil {
		fields = append(fields, blockchain.FieldSymbol)
	}
	if m.decimals != nil {
		fields = append(fields, blockchain.FieldDecimals)
	}
	if m.status != nil {
		fields = append(fields, blockchain.FieldStatus)
	}
	if m.token_address != nil {
		fields = append(fields, blockchain.FieldTokenAddress)
	}
	if m.token_abi != nil {
		fields = append(fields, blockchain.FieldTokenAbi)
	}
	if m.cold_address != nil {
		fields = append(fields, blockchain.FieldColdAddress)
	}
	if m.hot_address != nil {
		fields = append(fields, blockchain.FieldHotAddress)
	}
	if m.scan_block_num != nil {
		fields = append(fields, blockchain.FieldScanBlockNum)
	}
	if m.min_free_num != nil {
		fields = append(fields, blockchain.FieldMinFreeNum)
	}
	if m.min_confirm_num != nil {
		fields = append(fields, blockchain.FieldMinConfirmNum)
	}
	if m.withdraw_fee != nil {
		fields = append(fields, blockchain.FieldWithdrawFee)
	}
	if m.withdraw_fee_type != nil {
		fields = append(fields, blockchain.FieldWithdrawFeeType)
	}
	if m.min_deposit != nil {
		fields = append(fields, blockchain.FieldMinDeposit)
	}
	if m.min_withdraw != nil {
		fields = append(fields, blockchain.FieldMinWithdraw)
	}
	if m.min_collect != nil {
		fields = append(fields, blockchain.FieldMinCollect)
	}
	if m.gas_price != nil {
		fields = append(fields, blockchain.FieldGasPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockchainMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockchain.FieldCreatedAt:
		return m.CreatedAt()
	case blockchain.FieldUpdatedAt:
		return m.UpdatedAt()
	case blockchain.FieldDeletedAt:
		return m.DeletedAt()
	case blockchain.FieldChain:
		return m.Chain()
	case blockchain.FieldTypes:
		return m.Types()
	case blockchain.FieldSymbol:
		return m.Symbol()
	case blockchain.FieldDecimals:
		return m.Decimals()
	case blockchain.FieldStatus:
		return m.Status()
	case blockchain.FieldTokenAddress:
		return m.TokenAddress()
	case blockchain.FieldTokenAbi:
		return m.TokenAbi()
	case blockchain.FieldColdAddress:
		return m.ColdAddress()
	case blockchain.FieldHotAddress:
		return m.HotAddress()
	case blockchain.FieldScanBlockNum:
		return m.ScanBlockNum()
	case blockchain.FieldMinFreeNum:
		return m.MinFreeNum()
	case blockchain.FieldMinConfirmNum:
		return m.MinConfirmNum()
	case blockchain.FieldWithdrawFee:
		return m.WithdrawFee()
	case blockchain.FieldWithdrawFeeType:
		return m.WithdrawFeeType()
	case blockchain.FieldMinDeposit:
		return m.MinDeposit()
	case blockchain.FieldMinWithdraw:
		return m.MinWithdraw()
	case blockchain.FieldMinCollect:
		return m.MinCollect()
	case blockchain.FieldGasPrice:
		return m.GasPrice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockchainMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockchain.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blockchain.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case blockchain.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case blockchain.FieldChain:
		return m.OldChain(ctx)
	case blockchain.FieldTypes:
		return m.OldTypes(ctx)
	case blockchain.FieldSymbol:
		return m.OldSymbol(ctx)
	case blockchain.FieldDecimals:
		return m.OldDecimals(ctx)
	case blockchain.FieldStatus:
		return m.OldStatus(ctx)
	case blockchain.FieldTokenAddress:
		return m.OldTokenAddress(ctx)
	case blockchain.FieldTokenAbi:
		return m.OldTokenAbi(ctx)
	case blockchain.FieldColdAddress:
		return m.OldColdAddress(ctx)
	case blockchain.FieldHotAddress:
		return m.OldHotAddress(ctx)
	case blockchain.FieldScanBlockNum:
		return m.OldScanBlockNum(ctx)
	case blockchain.FieldMinFreeNum:
		return m.OldMinFreeNum(ctx)
	case blockchain.FieldMinConfirmNum:
		return m.OldMinConfirmNum(ctx)
	case blockchain.FieldWithdrawFee:
		return m.OldWithdrawFee(ctx)
	case blockchain.FieldWithdrawFeeType:
		return m.OldWithdrawFeeType(ctx)
	case blockchain.FieldMinDeposit:
		return m.OldMinDeposit(ctx)
	case blockchain.FieldMinWithdraw:
		return m.OldMinWithdraw(ctx)
	case blockchain.FieldMinCollect:
		return m.OldMinCollect(ctx)
	case blockchain.FieldGasPrice:
		return m.OldGasPrice(ctx)
	}
	return nil, fmt.Errorf("unknown Blockchain field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockchainMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockchain.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blockchain.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case blockchain.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case blockchain.FieldChain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChain(v)
		return nil
	case blockchain.FieldTypes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypes(v)
		return nil
	case blockchain.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case blockchain.FieldDecimals:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDecimals(v)
		return nil
	case blockchain.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case blockchain.FieldTokenAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenAddress(v)
		return nil
	case blockchain.FieldTokenAbi:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenAbi(v)
		return nil
	case blockchain.FieldColdAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColdAddress(v)
		return nil
	case blockchain.FieldHotAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHotAddress(v)
		return nil
	case blockchain.FieldScanBlockNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScanBlockNum(v)
		return nil
	case blockchain.FieldMinFreeNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinFreeNum(v)
		return nil
	case blockchain.FieldMinConfirmNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinConfirmNum(v)
		return nil
	case blockchain.FieldWithdrawFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithdrawFee(v)
		return nil
	case blockchain.FieldWithdrawFeeType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithdrawFeeType(v)
		return nil
	case blockchain.FieldMinDeposit:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinDeposit(v)
		return nil
	case blockchain.FieldMinWithdraw:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinWithdraw(v)
		return nil
	case blockchain.FieldMinCollect:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinCollect(v)
		return nil
	case blockchain.FieldGasPrice:
		v, ok := value.(schema.GasPrice)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGasPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Blockchain field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockchainMutation) AddedFields() []string {
	var fields []string
	if m.adddecimals != nil {
		fields = append(fields, blockchain.FieldDecimals)
	}
	if m.addstatus != nil {
		fields = append(fields, blockchain.FieldStatus)
	}
	if m.addscan_block_num != nil {
		fields = append(fields, blockchain.FieldScanBlockNum)
	}
	if m.addmin_free_num != nil {
		fields = append(fields, blockchain.FieldMinFreeNum)
	}
	if m.addmin_confirm_num != nil {
		fields = append(fields, blockchain.FieldMinConfirmNum)
	}
	if m.addwithdraw_fee != nil {
		fields = append(fields, blockchain.FieldWithdrawFee)
	}
	if m.addwithdraw_fee_type != nil {
		fields = append(fields, blockchain.FieldWithdrawFeeType)
	}
	if m.addmin_deposit != nil {
		fields = append(fields, blockchain.FieldMinDeposit)
	}
	if m.addmin_withdraw != nil {
		fields = append(fields, blockchain.FieldMinWithdraw)
	}
	if m.addmin_collect != nil {
		fields = append(fields, blockchain.FieldMinCollect)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockchainMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blockchain.FieldDecimals:
		return m.AddedDecimals()
	case blockchain.FieldStatus:
		return m.AddedStatus()
	case blockchain.FieldScanBlockNum:
		return m.AddedScanBlockNum()
	case blockchain.FieldMinFreeNum:
		return m.AddedMinFreeNum()
	case blockchain.FieldMinConfirmNum:
		return m.AddedMinConfirmNum()
	case blockchain.FieldWithdrawFee:
		return m.AddedWithdrawFee()
	case blockchain.FieldWithdrawFeeType:
		return m.AddedWithdrawFeeType()
	case blockchain.FieldMinDeposit:
		return m.AddedMinDeposit()
	case blockchain.FieldMinWithdraw:
		return m.AddedMinWithdraw()
	case blockchain.FieldMinCollect:
		return m.AddedMinCollect()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockchainMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blockchain.FieldDecimals:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDecimals(v)
		return nil
	case blockchain.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case blockchain.FieldScanBlockNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScanBlockNum(v)
		return nil
	case blockchain.FieldMinFreeNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinFreeNum(v)
		return nil
	case blockchain.FieldMinConfirmNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinConfirmNum(v)
		return nil
	case blockchain.FieldWithdrawFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWithdrawFee(v)
		return nil
	case blockchain.FieldWithdrawFeeType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWithdrawFeeType(v)
		return nil
	case blockchain.FieldMinDeposit:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinDeposit(v)
		return nil
	case blockchain.FieldMinWithdraw:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinWithdraw(v)
		return nil
	case blockchain.FieldMinCollect:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinCollect(v)
		return nil
	}
	return fmt.Errorf("unknown Blockchain numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockchainMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockchain.FieldCreatedAt) {
		fields = append(fields, blockchain.FieldCreatedAt)
	}
	if m.FieldCleared(blockchain.FieldUpdatedAt) {
		fields = append(fields, blockchain.FieldUpdatedAt)
	}
	if m.FieldCleared(blockchain.FieldDeletedAt) {
		fields = append(fields, blockchain.FieldDeletedAt)
	}
	if m.FieldCleared(blockchain.FieldTokenAbi) {
		fields = append(fields, blockchain.FieldTokenAbi)
	}
	if m.FieldCleared(blockchain.FieldGasPrice) {
		fields = append(fields, blockchain.FieldGasPrice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockchainMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockchainMutation) ClearField(name string) error {
	switch name {
	case blockchain.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case blockchain.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case blockchain.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case blockchain.FieldTokenAbi:
		m.ClearTokenAbi()
		return nil
	case blockchain.FieldGasPrice:
		m.ClearGasPrice()
		return nil
	}
	return fmt.Errorf("unknown Blockchain nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockchainMutation) ResetField(name string) error {
	switch name {
	case blockchain.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blockchain.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case blockchain.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case blockchain.FieldChain:
		m.ResetChain()
		return nil
	case blockchain.FieldTypes:
		m.ResetTypes()
		return nil
	case blockchain.FieldSymbol:
		m.ResetSymbol()
		return nil
	case blockchain.FieldDecimals:
		m.ResetDecimals()
		return nil
	case blockchain.FieldStatus:
		m.ResetStatus()
		return nil
	case blockchain.FieldTokenAddress:
		m.ResetTokenAddress()
		return nil
	case blockchain.FieldTokenAbi:
		m.ResetTokenAbi()
		return nil
	case blockchain.FieldColdAddress:
		m.ResetColdAddress()
		return nil
	case blockchain.FieldHotAddress:
		m.ResetHotAddress()
		return nil
	case blockchain.FieldScanBlockNum:
		m.ResetScanBlockNum()
		return nil
	case blockchain.FieldMinFreeNum:
		m.ResetMinFreeNum()
		return nil
	case blockchain.FieldMinConfirmNum:
		m.ResetMinConfirmNum()
		return nil
	case blockchain.FieldWithdrawFee:
		m.ResetWithdrawFee()
		return nil
	case blockchain.FieldWithdrawFeeType:
		m.ResetWithdrawFeeType()
		return nil
	case blockchain.FieldMinDeposit:
		m.ResetMinDeposit()
		return nil
	case blockchain.FieldMinWithdraw:
		m.ResetMinWithdraw()
		return nil
	case blockchain.FieldMinCollect:
		m.ResetMinCollect()
		return nil
	case blockchain.FieldGasPrice:
		m.ResetGasPrice()
		return nil
	}
	return fmt.Errorf("unknown Blockchain field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockchainMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockchainMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockchainMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockchainMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockchainMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockchainMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockchainMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Blockchain unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockchainMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Blockchain edge %s", name)
}

// NotifyMutation represents an operation that mutates the Notify nodes in the graph.
type NotifyMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	chain_id         *uint64
	addchain_id      *int64
	product_id       *uint64
	addproduct_id    *int64
	item_from        *uint64
	additem_from     *int64
	item_type        *int64
	additem_type     *int64
	nonce            *string
	notify_type      *string
	send_url         *string
	send_body        *string
	send_retry       *int64
	addsend_retry    *int64
	handle_status    *int64
	addhandle_status *int64
	handle_msg       *string
	handle_time      *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Notify, error)
	predicates       []predicate.Notify
}

var _ ent.Mutation = (*NotifyMutation)(nil)

// notifyOption allows management of the mutation configuration using functional options.
type notifyOption func(*NotifyMutation)

// newNotifyMutation creates new mutation for the Notify entity.
func newNotifyMutation(c config, op Op, opts ...notifyOption) *NotifyMutation {
	m := &NotifyMutation{
		config:        c,
		op:            op,
		typ:           TypeNotify,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifyID sets the ID field of the mutation.
func withNotifyID(id uint64) notifyOption {
	return func(m *NotifyMutation) {
		var (
			err   error
			once  sync.Once
			value *Notify
		)
		m.oldValue = func(ctx context.Context) (*Notify, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notify.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotify sets the old Notify of the mutation.
func withNotify(node *Notify) notifyOption {
	return func(m *NotifyMutation) {
		m.oldValue = func(context.Context) (*Notify, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notify entities.
func (m *NotifyMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifyMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifyMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notify.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notify entity.
// If the Notify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotifyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotifyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Notify entity.
// If the Notify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *NotifyMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[notify.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *NotifyMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[notify.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotifyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, notify.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NotifyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NotifyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Notify entity.
// If the Notify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NotifyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notify.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NotifyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notify.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NotifyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notify.FieldDeletedAt)
}

// SetChainID sets the "chain_id" field.
func (m *NotifyMutation) SetChainID(u uint64) {
	m.chain_id = &u
	m.addchain_id = nil
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *NotifyMutation) ChainID() (r uint64, exists bool) {
	v := m.chain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the Notify entity.
// If the Notify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyMutation) OldChainID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// AddChainID adds u to the "chain_id" field.
func (m *NotifyMutation) AddChainID(u int64) {
	if m.addchain_id != nil {
		*m.addchain_id += u
	} else {
		m.addchain_id = &u
	}
}

// AddedChainID returns the value that was added to the "chain_id" field in this mutation.
func (m *NotifyMutation) AddedChainID() (r int64, exists bool) {
	v := m.addchain_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *NotifyMutation) ResetChainID() {
	m.chain_id = nil
	m.addchain_id = nil
}

// SetProductID sets the "product_id" field.
func (m *NotifyMutation) SetProductID(u uint64) {
	m.product_id = &u
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *NotifyMutation) ProductID() (r uint64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the Notify entity.
// If the Notify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyMutation) OldProductID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds u to the "product_id" field.
func (m *NotifyMutation) AddProductID(u int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += u
	} else {
		m.addproduct_id = &u
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *NotifyMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductID resets all changes to the "product_id" field.
func (m *NotifyMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
}

// SetItemFrom sets the "item_from" field.
func (m *NotifyMutation) SetItemFrom(u uint64) {
	m.item_from = &u
	m.additem_from = nil
}

// ItemFrom returns the value of the "item_from" field in the mutation.
func (m *NotifyMutation) ItemFrom() (r uint64, exists bool) {
	v := m.item_from
	if v == nil {
		return
	}
	return *v, true
}

// OldItemFrom returns the old "item_from" field's value of the Notify entity.
// If the Notify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyMutation) OldItemFrom(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemFrom: %w", err)
	}
	return oldValue.ItemFrom, nil
}

// AddItemFrom adds u to the "item_from" field.
func (m *NotifyMutation) AddItemFrom(u int64) {
	if m.additem_from != nil {
		*m.additem_from += u
	} else {
		m.additem_from = &u
	}
}

// AddedItemFrom returns the value that was added to the "item_from" field in this mutation.
func (m *NotifyMutation) AddedItemFrom() (r int64, exists bool) {
	v := m.additem_from
	if v == nil {
		return
	}
	return *v, true
}

// ResetItemFrom resets all changes to the "item_from" field.
func (m *NotifyMutation) ResetItemFrom() {
	m.item_from = nil
	m.additem_from = nil
}

// SetItemType sets the "item_type" field.
func (m *NotifyMutation) SetItemType(i int64) {
	m.item_type = &i
	m.additem_type = nil
}

// ItemType returns the value of the "item_type" field in the mutation.
func (m *NotifyMutation) ItemType() (r int64, exists bool) {
	v := m.item_type
	if v == nil {
		return
	}
	return *v, true
}

// OldItemType returns the old "item_type" field's value of the Notify entity.
// If the Notify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyMutation) OldItemType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemType: %w", err)
	}
	return oldValue.ItemType, nil
}

// AddItemType adds i to the "item_type" field.
func (m *NotifyMutation) AddItemType(i int64) {
	if m.additem_type != nil {
		*m.additem_type += i
	} else {
		m.additem_type = &i
	}
}

// AddedItemType returns the value that was added to the "item_type" field in this mutation.
func (m *NotifyMutation) AddedItemType() (r int64, exists bool) {
	v := m.additem_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetItemType resets all changes to the "item_type" field.
func (m *NotifyMutation) ResetItemType() {
	m.item_type = nil
	m.additem_type = nil
}

// SetNonce sets the "nonce" field.
func (m *NotifyMutation) SetNonce(s string) {
	m.nonce = &s
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *NotifyMutation) Nonce() (r string, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the Notify entity.
// If the Notify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyMutation) OldNonce(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ResetNonce resets all changes to the "nonce" field.
func (m *NotifyMutation) ResetNonce() {
	m.nonce = nil
}

// SetNotifyType sets the "notify_type" field.
func (m *NotifyMutation) SetNotifyType(s string) {
	m.notify_type = &s
}

// NotifyType returns the value of the "notify_type" field in the mutation.
func (m *NotifyMutation) NotifyType() (r string, exists bool) {
	v := m.notify_type
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyType returns the old "notify_type" field's value of the Notify entity.
// If the Notify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyMutation) OldNotifyType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyType: %w", err)
	}
	return oldValue.NotifyType, nil
}

// ResetNotifyType resets all changes to the "notify_type" field.
func (m *NotifyMutation) ResetNotifyType() {
	m.notify_type = nil
}

// SetSendURL sets the "send_url" field.
func (m *NotifyMutation) SetSendURL(s string) {
	m.send_url = &s
}

// SendURL returns the value of the "send_url" field in the mutation.
func (m *NotifyMutation) SendURL() (r string, exists bool) {
	v := m.send_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSendURL returns the old "send_url" field's value of the Notify entity.
// If the Notify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyMutation) OldSendURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSendURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSendURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSendURL: %w", err)
	}
	return oldValue.SendURL, nil
}

// ResetSendURL resets all changes to the "send_url" field.
func (m *NotifyMutation) ResetSendURL() {
	m.send_url = nil
}

// SetSendBody sets the "send_body" field.
func (m *NotifyMutation) SetSendBody(s string) {
	m.send_body = &s
}

// SendBody returns the value of the "send_body" field in the mutation.
func (m *NotifyMutation) SendBody() (r string, exists bool) {
	v := m.send_body
	if v == nil {
		return
	}
	return *v, true
}

// OldSendBody returns the old "send_body" field's value of the Notify entity.
// If the Notify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyMutation) OldSendBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSendBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSendBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSendBody: %w", err)
	}
	return oldValue.SendBody, nil
}

// ResetSendBody resets all changes to the "send_body" field.
func (m *NotifyMutation) ResetSendBody() {
	m.send_body = nil
}

// SetSendRetry sets the "send_retry" field.
func (m *NotifyMutation) SetSendRetry(i int64) {
	m.send_retry = &i
	m.addsend_retry = nil
}

// SendRetry returns the value of the "send_retry" field in the mutation.
func (m *NotifyMutation) SendRetry() (r int64, exists bool) {
	v := m.send_retry
	if v == nil {
		return
	}
	return *v, true
}

// OldSendRetry returns the old "send_retry" field's value of the Notify entity.
// If the Notify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyMutation) OldSendRetry(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSendRetry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSendRetry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSendRetry: %w", err)
	}
	return oldValue.SendRetry, nil
}

// AddSendRetry adds i to the "send_retry" field.
func (m *NotifyMutation) AddSendRetry(i int64) {
	if m.addsend_retry != nil {
		*m.addsend_retry += i
	} else {
		m.addsend_retry = &i
	}
}

// AddedSendRetry returns the value that was added to the "send_retry" field in this mutation.
func (m *NotifyMutation) AddedSendRetry() (r int64, exists bool) {
	v := m.addsend_retry
	if v == nil {
		return
	}
	return *v, true
}

// ResetSendRetry resets all changes to the "send_retry" field.
func (m *NotifyMutation) ResetSendRetry() {
	m.send_retry = nil
	m.addsend_retry = nil
}

// SetHandleStatus sets the "handle_status" field.
func (m *NotifyMutation) SetHandleStatus(i int64) {
	m.handle_status = &i
	m.addhandle_status = nil
}

// HandleStatus returns the value of the "handle_status" field in the mutation.
func (m *NotifyMutation) HandleStatus() (r int64, exists bool) {
	v := m.handle_status
	if v == nil {
		return
	}
	return *v, true
}

// OldHandleStatus returns the old "handle_status" field's value of the Notify entity.
// If the Notify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyMutation) OldHandleStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandleStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandleStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandleStatus: %w", err)
	}
	return oldValue.HandleStatus, nil
}

// AddHandleStatus adds i to the "handle_status" field.
func (m *NotifyMutation) AddHandleStatus(i int64) {
	if m.addhandle_status != nil {
		*m.addhandle_status += i
	} else {
		m.addhandle_status = &i
	}
}

// AddedHandleStatus returns the value that was added to the "handle_status" field in this mutation.
func (m *NotifyMutation) AddedHandleStatus() (r int64, exists bool) {
	v := m.addhandle_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetHandleStatus resets all changes to the "handle_status" field.
func (m *NotifyMutation) ResetHandleStatus() {
	m.handle_status = nil
	m.addhandle_status = nil
}

// SetHandleMsg sets the "handle_msg" field.
func (m *NotifyMutation) SetHandleMsg(s string) {
	m.handle_msg = &s
}

// HandleMsg returns the value of the "handle_msg" field in the mutation.
func (m *NotifyMutation) HandleMsg() (r string, exists bool) {
	v := m.handle_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldHandleMsg returns the old "handle_msg" field's value of the Notify entity.
// If the Notify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyMutation) OldHandleMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandleMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandleMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandleMsg: %w", err)
	}
	return oldValue.HandleMsg, nil
}

// ResetHandleMsg resets all changes to the "handle_msg" field.
func (m *NotifyMutation) ResetHandleMsg() {
	m.handle_msg = nil
}

// SetHandleTime sets the "handle_time" field.
func (m *NotifyMutation) SetHandleTime(t time.Time) {
	m.handle_time = &t
}

// HandleTime returns the value of the "handle_time" field in the mutation.
func (m *NotifyMutation) HandleTime() (r time.Time, exists bool) {
	v := m.handle_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHandleTime returns the old "handle_time" field's value of the Notify entity.
// If the Notify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyMutation) OldHandleTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandleTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandleTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandleTime: %w", err)
	}
	return oldValue.HandleTime, nil
}

// ClearHandleTime clears the value of the "handle_time" field.
func (m *NotifyMutation) ClearHandleTime() {
	m.handle_time = nil
	m.clearedFields[notify.FieldHandleTime] = struct{}{}
}

// HandleTimeCleared returns if the "handle_time" field was cleared in this mutation.
func (m *NotifyMutation) HandleTimeCleared() bool {
	_, ok := m.clearedFields[notify.FieldHandleTime]
	return ok
}

// ResetHandleTime resets all changes to the "handle_time" field.
func (m *NotifyMutation) ResetHandleTime() {
	m.handle_time = nil
	delete(m.clearedFields, notify.FieldHandleTime)
}

// Where appends a list predicates to the NotifyMutation builder.
func (m *NotifyMutation) Where(ps ...predicate.Notify) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notify, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notify).
func (m *NotifyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifyMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, notify.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notify.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, notify.FieldDeletedAt)
	}
	if m.chain_id != nil {
		fields = append(fields, notify.FieldChainID)
	}
	if m.product_id != nil {
		fields = append(fields, notify.FieldProductID)
	}
	if m.item_from != nil {
		fields = append(fields, notify.FieldItemFrom)
	}
	if m.item_type != nil {
		fields = append(fields, notify.FieldItemType)
	}
	if m.nonce != nil {
		fields = append(fields, notify.FieldNonce)
	}
	if m.notify_type != nil {
		fields = append(fields, notify.FieldNotifyType)
	}
	if m.send_url != nil {
		fields = append(fields, notify.FieldSendURL)
	}
	if m.send_body != nil {
		fields = append(fields, notify.FieldSendBody)
	}
	if m.send_retry != nil {
		fields = append(fields, notify.FieldSendRetry)
	}
	if m.handle_status != nil {
		fields = append(fields, notify.FieldHandleStatus)
	}
	if m.handle_msg != nil {
		fields = append(fields, notify.FieldHandleMsg)
	}
	if m.handle_time != nil {
		fields = append(fields, notify.FieldHandleTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notify.FieldCreatedAt:
		return m.CreatedAt()
	case notify.FieldUpdatedAt:
		return m.UpdatedAt()
	case notify.FieldDeletedAt:
		return m.DeletedAt()
	case notify.FieldChainID:
		return m.ChainID()
	case notify.FieldProductID:
		return m.ProductID()
	case notify.FieldItemFrom:
		return m.ItemFrom()
	case notify.FieldItemType:
		return m.ItemType()
	case notify.FieldNonce:
		return m.Nonce()
	case notify.FieldNotifyType:
		return m.NotifyType()
	case notify.FieldSendURL:
		return m.SendURL()
	case notify.FieldSendBody:
		return m.SendBody()
	case notify.FieldSendRetry:
		return m.SendRetry()
	case notify.FieldHandleStatus:
		return m.HandleStatus()
	case notify.FieldHandleMsg:
		return m.HandleMsg()
	case notify.FieldHandleTime:
		return m.HandleTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notify.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notify.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notify.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case notify.FieldChainID:
		return m.OldChainID(ctx)
	case notify.FieldProductID:
		return m.OldProductID(ctx)
	case notify.FieldItemFrom:
		return m.OldItemFrom(ctx)
	case notify.FieldItemType:
		return m.OldItemType(ctx)
	case notify.FieldNonce:
		return m.OldNonce(ctx)
	case notify.FieldNotifyType:
		return m.OldNotifyType(ctx)
	case notify.FieldSendURL:
		return m.OldSendURL(ctx)
	case notify.FieldSendBody:
		return m.OldSendBody(ctx)
	case notify.FieldSendRetry:
		return m.OldSendRetry(ctx)
	case notify.FieldHandleStatus:
		return m.OldHandleStatus(ctx)
	case notify.FieldHandleMsg:
		return m.OldHandleMsg(ctx)
	case notify.FieldHandleTime:
		return m.OldHandleTime(ctx)
	}
	return nil, fmt.Errorf("unknown Notify field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notify.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notify.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notify.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case notify.FieldChainID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	case notify.FieldProductID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case notify.FieldItemFrom:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemFrom(v)
		return nil
	case notify.FieldItemType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemType(v)
		return nil
	case notify.FieldNonce:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	case notify.FieldNotifyType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyType(v)
		return nil
	case notify.FieldSendURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSendURL(v)
		return nil
	case notify.FieldSendBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSendBody(v)
		return nil
	case notify.FieldSendRetry:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSendRetry(v)
		return nil
	case notify.FieldHandleStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandleStatus(v)
		return nil
	case notify.FieldHandleMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandleMsg(v)
		return nil
	case notify.FieldHandleTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandleTime(v)
		return nil
	}
	return fmt.Errorf("unknown Notify field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifyMutation) AddedFields() []string {
	var fields []string
	if m.addchain_id != nil {
		fields = append(fields, notify.FieldChainID)
	}
	if m.addproduct_id != nil {
		fields = append(fields, notify.FieldProductID)
	}
	if m.additem_from != nil {
		fields = append(fields, notify.FieldItemFrom)
	}
	if m.additem_type != nil {
		fields = append(fields, notify.FieldItemType)
	}
	if m.addsend_retry != nil {
		fields = append(fields, notify.FieldSendRetry)
	}
	if m.addhandle_status != nil {
		fields = append(fields, notify.FieldHandleStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notify.FieldChainID:
		return m.AddedChainID()
	case notify.FieldProductID:
		return m.AddedProductID()
	case notify.FieldItemFrom:
		return m.AddedItemFrom()
	case notify.FieldItemType:
		return m.AddedItemType()
	case notify.FieldSendRetry:
		return m.AddedSendRetry()
	case notify.FieldHandleStatus:
		return m.AddedHandleStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notify.FieldChainID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChainID(v)
		return nil
	case notify.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case notify.FieldItemFrom:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddItemFrom(v)
		return nil
	case notify.FieldItemType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddItemType(v)
		return nil
	case notify.FieldSendRetry:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSendRetry(v)
		return nil
	case notify.FieldHandleStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHandleStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Notify numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notify.FieldUpdatedAt) {
		fields = append(fields, notify.FieldUpdatedAt)
	}
	if m.FieldCleared(notify.FieldDeletedAt) {
		fields = append(fields, notify.FieldDeletedAt)
	}
	if m.FieldCleared(notify.FieldHandleTime) {
		fields = append(fields, notify.FieldHandleTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifyMutation) ClearField(name string) error {
	switch name {
	case notify.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case notify.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case notify.FieldHandleTime:
		m.ClearHandleTime()
		return nil
	}
	return fmt.Errorf("unknown Notify nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifyMutation) ResetField(name string) error {
	switch name {
	case notify.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notify.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notify.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case notify.FieldChainID:
		m.ResetChainID()
		return nil
	case notify.FieldProductID:
		m.ResetProductID()
		return nil
	case notify.FieldItemFrom:
		m.ResetItemFrom()
		return nil
	case notify.FieldItemType:
		m.ResetItemType()
		return nil
	case notify.FieldNonce:
		m.ResetNonce()
		return nil
	case notify.FieldNotifyType:
		m.ResetNotifyType()
		return nil
	case notify.FieldSendURL:
		m.ResetSendURL()
		return nil
	case notify.FieldSendBody:
		m.ResetSendBody()
		return nil
	case notify.FieldSendRetry:
		m.ResetSendRetry()
		return nil
	case notify.FieldHandleStatus:
		m.ResetHandleStatus()
		return nil
	case notify.FieldHandleMsg:
		m.ResetHandleMsg()
		return nil
	case notify.FieldHandleTime:
		m.ResetHandleTime()
		return nil
	}
	return fmt.Errorf("unknown Notify field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Notify unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Notify edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	app_id             *string
	app_type           *int64
	addapp_type        *int64
	app_name           *string
	app_secret         *string
	app_status         *int64
	addapp_status      *int64
	withdraw_status    *int64
	addwithdraw_status *int64
	web_hook           *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Product, error)
	predicates         []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id uint64) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Product entities.
func (m *ProductMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProductMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[product.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProductMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[product.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, product.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProductMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[product.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProductMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[product.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, product.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProductMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[product.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProductMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[product.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, product.FieldDeletedAt)
}

// SetAppID sets the "app_id" field.
func (m *ProductMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *ProductMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *ProductMutation) ResetAppID() {
	m.app_id = nil
}

// SetAppType sets the "app_type" field.
func (m *ProductMutation) SetAppType(i int64) {
	m.app_type = &i
	m.addapp_type = nil
}

// AppType returns the value of the "app_type" field in the mutation.
func (m *ProductMutation) AppType() (r int64, exists bool) {
	v := m.app_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAppType returns the old "app_type" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldAppType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppType: %w", err)
	}
	return oldValue.AppType, nil
}

// AddAppType adds i to the "app_type" field.
func (m *ProductMutation) AddAppType(i int64) {
	if m.addapp_type != nil {
		*m.addapp_type += i
	} else {
		m.addapp_type = &i
	}
}

// AddedAppType returns the value that was added to the "app_type" field in this mutation.
func (m *ProductMutation) AddedAppType() (r int64, exists bool) {
	v := m.addapp_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppType resets all changes to the "app_type" field.
func (m *ProductMutation) ResetAppType() {
	m.app_type = nil
	m.addapp_type = nil
}

// SetAppName sets the "app_name" field.
func (m *ProductMutation) SetAppName(s string) {
	m.app_name = &s
}

// AppName returns the value of the "app_name" field in the mutation.
func (m *ProductMutation) AppName() (r string, exists bool) {
	v := m.app_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAppName returns the old "app_name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldAppName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppName: %w", err)
	}
	return oldValue.AppName, nil
}

// ResetAppName resets all changes to the "app_name" field.
func (m *ProductMutation) ResetAppName() {
	m.app_name = nil
}

// SetAppSecret sets the "app_secret" field.
func (m *ProductMutation) SetAppSecret(s string) {
	m.app_secret = &s
}

// AppSecret returns the value of the "app_secret" field in the mutation.
func (m *ProductMutation) AppSecret() (r string, exists bool) {
	v := m.app_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldAppSecret returns the old "app_secret" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldAppSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppSecret: %w", err)
	}
	return oldValue.AppSecret, nil
}

// ResetAppSecret resets all changes to the "app_secret" field.
func (m *ProductMutation) ResetAppSecret() {
	m.app_secret = nil
}

// SetAppStatus sets the "app_status" field.
func (m *ProductMutation) SetAppStatus(i int64) {
	m.app_status = &i
	m.addapp_status = nil
}

// AppStatus returns the value of the "app_status" field in the mutation.
func (m *ProductMutation) AppStatus() (r int64, exists bool) {
	v := m.app_status
	if v == nil {
		return
	}
	return *v, true
}

// OldAppStatus returns the old "app_status" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldAppStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppStatus: %w", err)
	}
	return oldValue.AppStatus, nil
}

// AddAppStatus adds i to the "app_status" field.
func (m *ProductMutation) AddAppStatus(i int64) {
	if m.addapp_status != nil {
		*m.addapp_status += i
	} else {
		m.addapp_status = &i
	}
}

// AddedAppStatus returns the value that was added to the "app_status" field in this mutation.
func (m *ProductMutation) AddedAppStatus() (r int64, exists bool) {
	v := m.addapp_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppStatus resets all changes to the "app_status" field.
func (m *ProductMutation) ResetAppStatus() {
	m.app_status = nil
	m.addapp_status = nil
}

// SetWithdrawStatus sets the "withdraw_status" field.
func (m *ProductMutation) SetWithdrawStatus(i int64) {
	m.withdraw_status = &i
	m.addwithdraw_status = nil
}

// WithdrawStatus returns the value of the "withdraw_status" field in the mutation.
func (m *ProductMutation) WithdrawStatus() (r int64, exists bool) {
	v := m.withdraw_status
	if v == nil {
		return
	}
	return *v, true
}

// OldWithdrawStatus returns the old "withdraw_status" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldWithdrawStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithdrawStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithdrawStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithdrawStatus: %w", err)
	}
	return oldValue.WithdrawStatus, nil
}

// AddWithdrawStatus adds i to the "withdraw_status" field.
func (m *ProductMutation) AddWithdrawStatus(i int64) {
	if m.addwithdraw_status != nil {
		*m.addwithdraw_status += i
	} else {
		m.addwithdraw_status = &i
	}
}

// AddedWithdrawStatus returns the value that was added to the "withdraw_status" field in this mutation.
func (m *ProductMutation) AddedWithdrawStatus() (r int64, exists bool) {
	v := m.addwithdraw_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetWithdrawStatus resets all changes to the "withdraw_status" field.
func (m *ProductMutation) ResetWithdrawStatus() {
	m.withdraw_status = nil
	m.addwithdraw_status = nil
}

// SetWebHook sets the "web_hook" field.
func (m *ProductMutation) SetWebHook(s string) {
	m.web_hook = &s
}

// WebHook returns the value of the "web_hook" field in the mutation.
func (m *ProductMutation) WebHook() (r string, exists bool) {
	v := m.web_hook
	if v == nil {
		return
	}
	return *v, true
}

// OldWebHook returns the old "web_hook" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldWebHook(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebHook is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebHook requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebHook: %w", err)
	}
	return oldValue.WebHook, nil
}

// ResetWebHook resets all changes to the "web_hook" field.
func (m *ProductMutation) ResetWebHook() {
	m.web_hook = nil
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, product.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, product.FieldAppID)
	}
	if m.app_type != nil {
		fields = append(fields, product.FieldAppType)
	}
	if m.app_name != nil {
		fields = append(fields, product.FieldAppName)
	}
	if m.app_secret != nil {
		fields = append(fields, product.FieldAppSecret)
	}
	if m.app_status != nil {
		fields = append(fields, product.FieldAppStatus)
	}
	if m.withdraw_status != nil {
		fields = append(fields, product.FieldWithdrawStatus)
	}
	if m.web_hook != nil {
		fields = append(fields, product.FieldWebHook)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldDeletedAt:
		return m.DeletedAt()
	case product.FieldAppID:
		return m.AppID()
	case product.FieldAppType:
		return m.AppType()
	case product.FieldAppName:
		return m.AppName()
	case product.FieldAppSecret:
		return m.AppSecret()
	case product.FieldAppStatus:
		return m.AppStatus()
	case product.FieldWithdrawStatus:
		return m.WithdrawStatus()
	case product.FieldWebHook:
		return m.WebHook()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case product.FieldAppID:
		return m.OldAppID(ctx)
	case product.FieldAppType:
		return m.OldAppType(ctx)
	case product.FieldAppName:
		return m.OldAppName(ctx)
	case product.FieldAppSecret:
		return m.OldAppSecret(ctx)
	case product.FieldAppStatus:
		return m.OldAppStatus(ctx)
	case product.FieldWithdrawStatus:
		return m.OldWithdrawStatus(ctx)
	case product.FieldWebHook:
		return m.OldWebHook(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case product.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case product.FieldAppType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppType(v)
		return nil
	case product.FieldAppName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppName(v)
		return nil
	case product.FieldAppSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppSecret(v)
		return nil
	case product.FieldAppStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppStatus(v)
		return nil
	case product.FieldWithdrawStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithdrawStatus(v)
		return nil
	case product.FieldWebHook:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebHook(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addapp_type != nil {
		fields = append(fields, product.FieldAppType)
	}
	if m.addapp_status != nil {
		fields = append(fields, product.FieldAppStatus)
	}
	if m.addwithdraw_status != nil {
		fields = append(fields, product.FieldWithdrawStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldAppType:
		return m.AddedAppType()
	case product.FieldAppStatus:
		return m.AddedAppStatus()
	case product.FieldWithdrawStatus:
		return m.AddedWithdrawStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldAppType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppType(v)
		return nil
	case product.FieldAppStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppStatus(v)
		return nil
	case product.FieldWithdrawStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWithdrawStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldCreatedAt) {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.FieldCleared(product.FieldUpdatedAt) {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.FieldCleared(product.FieldDeletedAt) {
		fields = append(fields, product.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case product.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case product.FieldAppID:
		m.ResetAppID()
		return nil
	case product.FieldAppType:
		m.ResetAppType()
		return nil
	case product.FieldAppName:
		m.ResetAppName()
		return nil
	case product.FieldAppSecret:
		m.ResetAppSecret()
		return nil
	case product.FieldAppStatus:
		m.ResetAppStatus()
		return nil
	case product.FieldWithdrawStatus:
		m.ResetWithdrawStatus()
		return nil
	case product.FieldWebHook:
		m.ResetWebHook()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Product edge %s", name)
}

// TSessionMutation represents an operation that mutates the TSession nodes in the graph.
type TSessionMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	key_name      *string
	key_value     *string
	ip            *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TSession, error)
	predicates    []predicate.TSession
}

var _ ent.Mutation = (*TSessionMutation)(nil)

// tsessionOption allows management of the mutation configuration using functional options.
type tsessionOption func(*TSessionMutation)

// newTSessionMutation creates new mutation for the TSession entity.
func newTSessionMutation(c config, op Op, opts ...tsessionOption) *TSessionMutation {
	m := &TSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeTSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTSessionID sets the ID field of the mutation.
func withTSessionID(id uint64) tsessionOption {
	return func(m *TSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *TSession
		)
		m.oldValue = func(ctx context.Context) (*TSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTSession sets the old TSession of the mutation.
func withTSession(node *TSession) tsessionOption {
	return func(m *TSessionMutation) {
		m.oldValue = func(context.Context) (*TSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TSession entities.
func (m *TSessionMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TSessionMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TSessionMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKeyName sets the "key_name" field.
func (m *TSessionMutation) SetKeyName(s string) {
	m.key_name = &s
}

// KeyName returns the value of the "key_name" field in the mutation.
func (m *TSessionMutation) KeyName() (r string, exists bool) {
	v := m.key_name
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyName returns the old "key_name" field's value of the TSession entity.
// If the TSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSessionMutation) OldKeyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyName: %w", err)
	}
	return oldValue.KeyName, nil
}

// ResetKeyName resets all changes to the "key_name" field.
func (m *TSessionMutation) ResetKeyName() {
	m.key_name = nil
}

// SetKeyValue sets the "key_value" field.
func (m *TSessionMutation) SetKeyValue(s string) {
	m.key_value = &s
}

// KeyValue returns the value of the "key_value" field in the mutation.
func (m *TSessionMutation) KeyValue() (r string, exists bool) {
	v := m.key_value
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyValue returns the old "key_value" field's value of the TSession entity.
// If the TSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSessionMutation) OldKeyValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyValue: %w", err)
	}
	return oldValue.KeyValue, nil
}

// ResetKeyValue resets all changes to the "key_value" field.
func (m *TSessionMutation) ResetKeyValue() {
	m.key_value = nil
}

// SetIP sets the "ip" field.
func (m *TSessionMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *TSessionMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the TSession entity.
// If the TSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSessionMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *TSessionMutation) ResetIP() {
	m.ip = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TSession entity.
// If the TSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TSessionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tsession.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TSessionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tsession.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TSessionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tsession.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TSessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TSessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TSession entity.
// If the TSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TSessionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tsession.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TSessionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tsession.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TSessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tsession.FieldUpdatedAt)
}

// Where appends a list predicates to the TSessionMutation builder.
func (m *TSessionMutation) Where(ps ...predicate.TSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TSession).
func (m *TSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TSessionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.key_name != nil {
		fields = append(fields, tsession.FieldKeyName)
	}
	if m.key_value != nil {
		fields = append(fields, tsession.FieldKeyValue)
	}
	if m.ip != nil {
		fields = append(fields, tsession.FieldIP)
	}
	if m.created_at != nil {
		fields = append(fields, tsession.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tsession.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tsession.FieldKeyName:
		return m.KeyName()
	case tsession.FieldKeyValue:
		return m.KeyValue()
	case tsession.FieldIP:
		return m.IP()
	case tsession.FieldCreatedAt:
		return m.CreatedAt()
	case tsession.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tsession.FieldKeyName:
		return m.OldKeyName(ctx)
	case tsession.FieldKeyValue:
		return m.OldKeyValue(ctx)
	case tsession.FieldIP:
		return m.OldIP(ctx)
	case tsession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tsession.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tsession.FieldKeyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyName(v)
		return nil
	case tsession.FieldKeyValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyValue(v)
		return nil
	case tsession.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case tsession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tsession.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tsession.FieldCreatedAt) {
		fields = append(fields, tsession.FieldCreatedAt)
	}
	if m.FieldCleared(tsession.FieldUpdatedAt) {
		fields = append(fields, tsession.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TSessionMutation) ClearField(name string) error {
	switch name {
	case tsession.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tsession.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TSessionMutation) ResetField(name string) error {
	switch name {
	case tsession.FieldKeyName:
		m.ResetKeyName()
		return nil
	case tsession.FieldKeyValue:
		m.ResetKeyValue()
		return nil
	case tsession.FieldIP:
		m.ResetIP()
		return nil
	case tsession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tsession.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TSessionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TSessionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TSessionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TSessionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TSession edge %s", name)
}

// TransferMutation represents an operation that mutates the Transfer nodes in the graph.
type TransferMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	related_type     *int64
	addrelated_type  *int64
	related_id       *uint64
	addrelated_id    *int64
	chain_id         *uint64
	addchain_id      *int64
	tx_id            *string
	from_address     *string
	to_address       *string
	amount_str       *string
	amount_raw       *decimal.Decimal
	addamount_raw    *decimal.Decimal
	handle_status    *int64
	addhandle_status *int64
	handle_msg       *string
	handle_time      *time.Time
	gas              *int64
	addgas           *int64
	gas_price        *int64
	addgas_price     *int64
	nonce            *int64
	addnonce         *int64
	hex              *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Transfer, error)
	predicates       []predicate.Transfer
}

var _ ent.Mutation = (*TransferMutation)(nil)

// transferOption allows management of the mutation configuration using functional options.
type transferOption func(*TransferMutation)

// newTransferMutation creates new mutation for the Transfer entity.
func newTransferMutation(c config, op Op, opts ...transferOption) *TransferMutation {
	m := &TransferMutation{
		config:        c,
		op:            op,
		typ:           TypeTransfer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransferID sets the ID field of the mutation.
func withTransferID(id uint64) transferOption {
	return func(m *TransferMutation) {
		var (
			err   error
			once  sync.Once
			value *Transfer
		)
		m.oldValue = func(ctx context.Context) (*Transfer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transfer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransfer sets the old Transfer of the mutation.
func withTransfer(node *Transfer) transferOption {
	return func(m *TransferMutation) {
		m.oldValue = func(context.Context) (*Transfer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransferMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransferMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transfer entities.
func (m *TransferMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransferMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransferMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transfer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TransferMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransferMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransferMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TransferMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TransferMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TransferMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[transfer.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TransferMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[transfer.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TransferMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, transfer.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TransferMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TransferMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TransferMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[transfer.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TransferMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[transfer.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TransferMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, transfer.FieldDeletedAt)
}

// SetRelatedType sets the "related_type" field.
func (m *TransferMutation) SetRelatedType(i int64) {
	m.related_type = &i
	m.addrelated_type = nil
}

// RelatedType returns the value of the "related_type" field in the mutation.
func (m *TransferMutation) RelatedType() (r int64, exists bool) {
	v := m.related_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRelatedType returns the old "related_type" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldRelatedType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelatedType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelatedType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelatedType: %w", err)
	}
	return oldValue.RelatedType, nil
}

// AddRelatedType adds i to the "related_type" field.
func (m *TransferMutation) AddRelatedType(i int64) {
	if m.addrelated_type != nil {
		*m.addrelated_type += i
	} else {
		m.addrelated_type = &i
	}
}

// AddedRelatedType returns the value that was added to the "related_type" field in this mutation.
func (m *TransferMutation) AddedRelatedType() (r int64, exists bool) {
	v := m.addrelated_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetRelatedType resets all changes to the "related_type" field.
func (m *TransferMutation) ResetRelatedType() {
	m.related_type = nil
	m.addrelated_type = nil
}

// SetRelatedID sets the "related_id" field.
func (m *TransferMutation) SetRelatedID(u uint64) {
	m.related_id = &u
	m.addrelated_id = nil
}

// RelatedID returns the value of the "related_id" field in the mutation.
func (m *TransferMutation) RelatedID() (r uint64, exists bool) {
	v := m.related_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRelatedID returns the old "related_id" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldRelatedID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelatedID: %w", err)
	}
	return oldValue.RelatedID, nil
}

// AddRelatedID adds u to the "related_id" field.
func (m *TransferMutation) AddRelatedID(u int64) {
	if m.addrelated_id != nil {
		*m.addrelated_id += u
	} else {
		m.addrelated_id = &u
	}
}

// AddedRelatedID returns the value that was added to the "related_id" field in this mutation.
func (m *TransferMutation) AddedRelatedID() (r int64, exists bool) {
	v := m.addrelated_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRelatedID resets all changes to the "related_id" field.
func (m *TransferMutation) ResetRelatedID() {
	m.related_id = nil
	m.addrelated_id = nil
}

// SetChainID sets the "chain_id" field.
func (m *TransferMutation) SetChainID(u uint64) {
	m.chain_id = &u
	m.addchain_id = nil
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *TransferMutation) ChainID() (r uint64, exists bool) {
	v := m.chain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldChainID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// AddChainID adds u to the "chain_id" field.
func (m *TransferMutation) AddChainID(u int64) {
	if m.addchain_id != nil {
		*m.addchain_id += u
	} else {
		m.addchain_id = &u
	}
}

// AddedChainID returns the value that was added to the "chain_id" field in this mutation.
func (m *TransferMutation) AddedChainID() (r int64, exists bool) {
	v := m.addchain_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *TransferMutation) ResetChainID() {
	m.chain_id = nil
	m.addchain_id = nil
}

// SetTxID sets the "tx_id" field.
func (m *TransferMutation) SetTxID(s string) {
	m.tx_id = &s
}

// TxID returns the value of the "tx_id" field in the mutation.
func (m *TransferMutation) TxID() (r string, exists bool) {
	v := m.tx_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTxID returns the old "tx_id" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldTxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxID: %w", err)
	}
	return oldValue.TxID, nil
}

// ResetTxID resets all changes to the "tx_id" field.
func (m *TransferMutation) ResetTxID() {
	m.tx_id = nil
}

// SetFromAddress sets the "from_address" field.
func (m *TransferMutation) SetFromAddress(s string) {
	m.from_address = &s
}

// FromAddress returns the value of the "from_address" field in the mutation.
func (m *TransferMutation) FromAddress() (r string, exists bool) {
	v := m.from_address
	if v == nil {
		return
	}
	return *v, true
}

// OldFromAddress returns the old "from_address" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldFromAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromAddress: %w", err)
	}
	return oldValue.FromAddress, nil
}

// ResetFromAddress resets all changes to the "from_address" field.
func (m *TransferMutation) ResetFromAddress() {
	m.from_address = nil
}

// SetToAddress sets the "to_address" field.
func (m *TransferMutation) SetToAddress(s string) {
	m.to_address = &s
}

// ToAddress returns the value of the "to_address" field in the mutation.
func (m *TransferMutation) ToAddress() (r string, exists bool) {
	v := m.to_address
	if v == nil {
		return
	}
	return *v, true
}

// OldToAddress returns the old "to_address" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldToAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToAddress: %w", err)
	}
	return oldValue.ToAddress, nil
}

// ResetToAddress resets all changes to the "to_address" field.
func (m *TransferMutation) ResetToAddress() {
	m.to_address = nil
}

// SetAmountStr sets the "amount_str" field.
func (m *TransferMutation) SetAmountStr(s string) {
	m.amount_str = &s
}

// AmountStr returns the value of the "amount_str" field in the mutation.
func (m *TransferMutation) AmountStr() (r string, exists bool) {
	v := m.amount_str
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountStr returns the old "amount_str" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldAmountStr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountStr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountStr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountStr: %w", err)
	}
	return oldValue.AmountStr, nil
}

// ResetAmountStr resets all changes to the "amount_str" field.
func (m *TransferMutation) ResetAmountStr() {
	m.amount_str = nil
}

// SetAmountRaw sets the "amount_raw" field.
func (m *TransferMutation) SetAmountRaw(d decimal.Decimal) {
	m.amount_raw = &d
	m.addamount_raw = nil
}

// AmountRaw returns the value of the "amount_raw" field in the mutation.
func (m *TransferMutation) AmountRaw() (r decimal.Decimal, exists bool) {
	v := m.amount_raw
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountRaw returns the old "amount_raw" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldAmountRaw(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountRaw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountRaw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountRaw: %w", err)
	}
	return oldValue.AmountRaw, nil
}

// AddAmountRaw adds d to the "amount_raw" field.
func (m *TransferMutation) AddAmountRaw(d decimal.Decimal) {
	if m.addamount_raw != nil {
		*m.addamount_raw = m.addamount_raw.Add(d)
	} else {
		m.addamount_raw = &d
	}
}

// AddedAmountRaw returns the value that was added to the "amount_raw" field in this mutation.
func (m *TransferMutation) AddedAmountRaw() (r decimal.Decimal, exists bool) {
	v := m.addamount_raw
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmountRaw resets all changes to the "amount_raw" field.
func (m *TransferMutation) ResetAmountRaw() {
	m.amount_raw = nil
	m.addamount_raw = nil
}

// SetHandleStatus sets the "handle_status" field.
func (m *TransferMutation) SetHandleStatus(i int64) {
	m.handle_status = &i
	m.addhandle_status = nil
}

// HandleStatus returns the value of the "handle_status" field in the mutation.
func (m *TransferMutation) HandleStatus() (r int64, exists bool) {
	v := m.handle_status
	if v == nil {
		return
	}
	return *v, true
}

// OldHandleStatus returns the old "handle_status" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldHandleStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandleStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandleStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandleStatus: %w", err)
	}
	return oldValue.HandleStatus, nil
}

// AddHandleStatus adds i to the "handle_status" field.
func (m *TransferMutation) AddHandleStatus(i int64) {
	if m.addhandle_status != nil {
		*m.addhandle_status += i
	} else {
		m.addhandle_status = &i
	}
}

// AddedHandleStatus returns the value that was added to the "handle_status" field in this mutation.
func (m *TransferMutation) AddedHandleStatus() (r int64, exists bool) {
	v := m.addhandle_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetHandleStatus resets all changes to the "handle_status" field.
func (m *TransferMutation) ResetHandleStatus() {
	m.handle_status = nil
	m.addhandle_status = nil
}

// SetHandleMsg sets the "handle_msg" field.
func (m *TransferMutation) SetHandleMsg(s string) {
	m.handle_msg = &s
}

// HandleMsg returns the value of the "handle_msg" field in the mutation.
func (m *TransferMutation) HandleMsg() (r string, exists bool) {
	v := m.handle_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldHandleMsg returns the old "handle_msg" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldHandleMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandleMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandleMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandleMsg: %w", err)
	}
	return oldValue.HandleMsg, nil
}

// ResetHandleMsg resets all changes to the "handle_msg" field.
func (m *TransferMutation) ResetHandleMsg() {
	m.handle_msg = nil
}

// SetHandleTime sets the "handle_time" field.
func (m *TransferMutation) SetHandleTime(t time.Time) {
	m.handle_time = &t
}

// HandleTime returns the value of the "handle_time" field in the mutation.
func (m *TransferMutation) HandleTime() (r time.Time, exists bool) {
	v := m.handle_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHandleTime returns the old "handle_time" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldHandleTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandleTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandleTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandleTime: %w", err)
	}
	return oldValue.HandleTime, nil
}

// ClearHandleTime clears the value of the "handle_time" field.
func (m *TransferMutation) ClearHandleTime() {
	m.handle_time = nil
	m.clearedFields[transfer.FieldHandleTime] = struct{}{}
}

// HandleTimeCleared returns if the "handle_time" field was cleared in this mutation.
func (m *TransferMutation) HandleTimeCleared() bool {
	_, ok := m.clearedFields[transfer.FieldHandleTime]
	return ok
}

// ResetHandleTime resets all changes to the "handle_time" field.
func (m *TransferMutation) ResetHandleTime() {
	m.handle_time = nil
	delete(m.clearedFields, transfer.FieldHandleTime)
}

// SetGas sets the "gas" field.
func (m *TransferMutation) SetGas(i int64) {
	m.gas = &i
	m.addgas = nil
}

// Gas returns the value of the "gas" field in the mutation.
func (m *TransferMutation) Gas() (r int64, exists bool) {
	v := m.gas
	if v == nil {
		return
	}
	return *v, true
}

// OldGas returns the old "gas" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldGas(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGas is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGas requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGas: %w", err)
	}
	return oldValue.Gas, nil
}

// AddGas adds i to the "gas" field.
func (m *TransferMutation) AddGas(i int64) {
	if m.addgas != nil {
		*m.addgas += i
	} else {
		m.addgas = &i
	}
}

// AddedGas returns the value that was added to the "gas" field in this mutation.
func (m *TransferMutation) AddedGas() (r int64, exists bool) {
	v := m.addgas
	if v == nil {
		return
	}
	return *v, true
}

// ResetGas resets all changes to the "gas" field.
func (m *TransferMutation) ResetGas() {
	m.gas = nil
	m.addgas = nil
}

// SetGasPrice sets the "gas_price" field.
func (m *TransferMutation) SetGasPrice(i int64) {
	m.gas_price = &i
	m.addgas_price = nil
}

// GasPrice returns the value of the "gas_price" field in the mutation.
func (m *TransferMutation) GasPrice() (r int64, exists bool) {
	v := m.gas_price
	if v == nil {
		return
	}
	return *v, true
}

// OldGasPrice returns the old "gas_price" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldGasPrice(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGasPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGasPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGasPrice: %w", err)
	}
	return oldValue.GasPrice, nil
}

// AddGasPrice adds i to the "gas_price" field.
func (m *TransferMutation) AddGasPrice(i int64) {
	if m.addgas_price != nil {
		*m.addgas_price += i
	} else {
		m.addgas_price = &i
	}
}

// AddedGasPrice returns the value that was added to the "gas_price" field in this mutation.
func (m *TransferMutation) AddedGasPrice() (r int64, exists bool) {
	v := m.addgas_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetGasPrice resets all changes to the "gas_price" field.
func (m *TransferMutation) ResetGasPrice() {
	m.gas_price = nil
	m.addgas_price = nil
}

// SetNonce sets the "nonce" field.
func (m *TransferMutation) SetNonce(i int64) {
	m.nonce = &i
	m.addnonce = nil
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *TransferMutation) Nonce() (r int64, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldNonce(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// AddNonce adds i to the "nonce" field.
func (m *TransferMutation) AddNonce(i int64) {
	if m.addnonce != nil {
		*m.addnonce += i
	} else {
		m.addnonce = &i
	}
}

// AddedNonce returns the value that was added to the "nonce" field in this mutation.
func (m *TransferMutation) AddedNonce() (r int64, exists bool) {
	v := m.addnonce
	if v == nil {
		return
	}
	return *v, true
}

// ResetNonce resets all changes to the "nonce" field.
func (m *TransferMutation) ResetNonce() {
	m.nonce = nil
	m.addnonce = nil
}

// SetHex sets the "hex" field.
func (m *TransferMutation) SetHex(s string) {
	m.hex = &s
}

// Hex returns the value of the "hex" field in the mutation.
func (m *TransferMutation) Hex() (r string, exists bool) {
	v := m.hex
	if v == nil {
		return
	}
	return *v, true
}

// OldHex returns the old "hex" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldHex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHex: %w", err)
	}
	return oldValue.Hex, nil
}

// ResetHex resets all changes to the "hex" field.
func (m *TransferMutation) ResetHex() {
	m.hex = nil
}

// Where appends a list predicates to the TransferMutation builder.
func (m *TransferMutation) Where(ps ...predicate.Transfer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransferMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransferMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transfer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransferMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransferMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transfer).
func (m *TransferMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransferMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, transfer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, transfer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, transfer.FieldDeletedAt)
	}
	if m.related_type != nil {
		fields = append(fields, transfer.FieldRelatedType)
	}
	if m.related_id != nil {
		fields = append(fields, transfer.FieldRelatedID)
	}
	if m.chain_id != nil {
		fields = append(fields, transfer.FieldChainID)
	}
	if m.tx_id != nil {
		fields = append(fields, transfer.FieldTxID)
	}
	if m.from_address != nil {
		fields = append(fields, transfer.FieldFromAddress)
	}
	if m.to_address != nil {
		fields = append(fields, transfer.FieldToAddress)
	}
	if m.amount_str != nil {
		fields = append(fields, transfer.FieldAmountStr)
	}
	if m.amount_raw != nil {
		fields = append(fields, transfer.FieldAmountRaw)
	}
	if m.handle_status != nil {
		fields = append(fields, transfer.FieldHandleStatus)
	}
	if m.handle_msg != nil {
		fields = append(fields, transfer.FieldHandleMsg)
	}
	if m.handle_time != nil {
		fields = append(fields, transfer.FieldHandleTime)
	}
	if m.gas != nil {
		fields = append(fields, transfer.FieldGas)
	}
	if m.gas_price != nil {
		fields = append(fields, transfer.FieldGasPrice)
	}
	if m.nonce != nil {
		fields = append(fields, transfer.FieldNonce)
	}
	if m.hex != nil {
		fields = append(fields, transfer.FieldHex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransferMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transfer.FieldCreatedAt:
		return m.CreatedAt()
	case transfer.FieldUpdatedAt:
		return m.UpdatedAt()
	case transfer.FieldDeletedAt:
		return m.DeletedAt()
	case transfer.FieldRelatedType:
		return m.RelatedType()
	case transfer.FieldRelatedID:
		return m.RelatedID()
	case transfer.FieldChainID:
		return m.ChainID()
	case transfer.FieldTxID:
		return m.TxID()
	case transfer.FieldFromAddress:
		return m.FromAddress()
	case transfer.FieldToAddress:
		return m.ToAddress()
	case transfer.FieldAmountStr:
		return m.AmountStr()
	case transfer.FieldAmountRaw:
		return m.AmountRaw()
	case transfer.FieldHandleStatus:
		return m.HandleStatus()
	case transfer.FieldHandleMsg:
		return m.HandleMsg()
	case transfer.FieldHandleTime:
		return m.HandleTime()
	case transfer.FieldGas:
		return m.Gas()
	case transfer.FieldGasPrice:
		return m.GasPrice()
	case transfer.FieldNonce:
		return m.Nonce()
	case transfer.FieldHex:
		return m.Hex()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransferMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transfer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transfer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case transfer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case transfer.FieldRelatedType:
		return m.OldRelatedType(ctx)
	case transfer.FieldRelatedID:
		return m.OldRelatedID(ctx)
	case transfer.FieldChainID:
		return m.OldChainID(ctx)
	case transfer.FieldTxID:
		return m.OldTxID(ctx)
	case transfer.FieldFromAddress:
		return m.OldFromAddress(ctx)
	case transfer.FieldToAddress:
		return m.OldToAddress(ctx)
	case transfer.FieldAmountStr:
		return m.OldAmountStr(ctx)
	case transfer.FieldAmountRaw:
		return m.OldAmountRaw(ctx)
	case transfer.FieldHandleStatus:
		return m.OldHandleStatus(ctx)
	case transfer.FieldHandleMsg:
		return m.OldHandleMsg(ctx)
	case transfer.FieldHandleTime:
		return m.OldHandleTime(ctx)
	case transfer.FieldGas:
		return m.OldGas(ctx)
	case transfer.FieldGasPrice:
		return m.OldGasPrice(ctx)
	case transfer.FieldNonce:
		return m.OldNonce(ctx)
	case transfer.FieldHex:
		return m.OldHex(ctx)
	}
	return nil, fmt.Errorf("unknown Transfer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transfer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transfer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case transfer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case transfer.FieldRelatedType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelatedType(v)
		return nil
	case transfer.FieldRelatedID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelatedID(v)
		return nil
	case transfer.FieldChainID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	case transfer.FieldTxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxID(v)
		return nil
	case transfer.FieldFromAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromAddress(v)
		return nil
	case transfer.FieldToAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToAddress(v)
		return nil
	case transfer.FieldAmountStr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountStr(v)
		return nil
	case transfer.FieldAmountRaw:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountRaw(v)
		return nil
	case transfer.FieldHandleStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandleStatus(v)
		return nil
	case transfer.FieldHandleMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandleMsg(v)
		return nil
	case transfer.FieldHandleTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandleTime(v)
		return nil
	case transfer.FieldGas:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGas(v)
		return nil
	case transfer.FieldGasPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGasPrice(v)
		return nil
	case transfer.FieldNonce:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	case transfer.FieldHex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHex(v)
		return nil
	}
	return fmt.Errorf("unknown Transfer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransferMutation) AddedFields() []string {
	var fields []string
	if m.addrelated_type != nil {
		fields = append(fields, transfer.FieldRelatedType)
	}
	if m.addrelated_id != nil {
		fields = append(fields, transfer.FieldRelatedID)
	}
	if m.addchain_id != nil {
		fields = append(fields, transfer.FieldChainID)
	}
	if m.addamount_raw != nil {
		fields = append(fields, transfer.FieldAmountRaw)
	}
	if m.addhandle_status != nil {
		fields = append(fields, transfer.FieldHandleStatus)
	}
	if m.addgas != nil {
		fields = append(fields, transfer.FieldGas)
	}
	if m.addgas_price != nil {
		fields = append(fields, transfer.FieldGasPrice)
	}
	if m.addnonce != nil {
		fields = append(fields, transfer.FieldNonce)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransferMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transfer.FieldRelatedType:
		return m.AddedRelatedType()
	case transfer.FieldRelatedID:
		return m.AddedRelatedID()
	case transfer.FieldChainID:
		return m.AddedChainID()
	case transfer.FieldAmountRaw:
		return m.AddedAmountRaw()
	case transfer.FieldHandleStatus:
		return m.AddedHandleStatus()
	case transfer.FieldGas:
		return m.AddedGas()
	case transfer.FieldGasPrice:
		return m.AddedGasPrice()
	case transfer.FieldNonce:
		return m.AddedNonce()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transfer.FieldRelatedType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelatedType(v)
		return nil
	case transfer.FieldRelatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelatedID(v)
		return nil
	case transfer.FieldChainID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChainID(v)
		return nil
	case transfer.FieldAmountRaw:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmountRaw(v)
		return nil
	case transfer.FieldHandleStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHandleStatus(v)
		return nil
	case transfer.FieldGas:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGas(v)
		return nil
	case transfer.FieldGasPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGasPrice(v)
		return nil
	case transfer.FieldNonce:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNonce(v)
		return nil
	}
	return fmt.Errorf("unknown Transfer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransferMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transfer.FieldUpdatedAt) {
		fields = append(fields, transfer.FieldUpdatedAt)
	}
	if m.FieldCleared(transfer.FieldDeletedAt) {
		fields = append(fields, transfer.FieldDeletedAt)
	}
	if m.FieldCleared(transfer.FieldHandleTime) {
		fields = append(fields, transfer.FieldHandleTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransferMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransferMutation) ClearField(name string) error {
	switch name {
	case transfer.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case transfer.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case transfer.FieldHandleTime:
		m.ClearHandleTime()
		return nil
	}
	return fmt.Errorf("unknown Transfer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransferMutation) ResetField(name string) error {
	switch name {
	case transfer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transfer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case transfer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case transfer.FieldRelatedType:
		m.ResetRelatedType()
		return nil
	case transfer.FieldRelatedID:
		m.ResetRelatedID()
		return nil
	case transfer.FieldChainID:
		m.ResetChainID()
		return nil
	case transfer.FieldTxID:
		m.ResetTxID()
		return nil
	case transfer.FieldFromAddress:
		m.ResetFromAddress()
		return nil
	case transfer.FieldToAddress:
		m.ResetToAddress()
		return nil
	case transfer.FieldAmountStr:
		m.ResetAmountStr()
		return nil
	case transfer.FieldAmountRaw:
		m.ResetAmountRaw()
		return nil
	case transfer.FieldHandleStatus:
		m.ResetHandleStatus()
		return nil
	case transfer.FieldHandleMsg:
		m.ResetHandleMsg()
		return nil
	case transfer.FieldHandleTime:
		m.ResetHandleTime()
		return nil
	case transfer.FieldGas:
		m.ResetGas()
		return nil
	case transfer.FieldGasPrice:
		m.ResetGasPrice()
		return nil
	case transfer.FieldNonce:
		m.ResetNonce()
		return nil
	case transfer.FieldHex:
		m.ResetHex()
		return nil
	}
	return fmt.Errorf("unknown Transfer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransferMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransferMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransferMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransferMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransferMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransferMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransferMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Transfer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransferMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Transfer edge %s", name)
}

// TxnMutation represents an operation that mutates the Txn nodes in the graph.
type TxnMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	tx_id             *string
	chain_id          *uint64
	addchain_id       *int64
	product_id        *int64
	addproduct_id     *int64
	from_address      *string
	to_address        *string
	amount_str        *string
	amount_raw        *decimal.Decimal
	addamount_raw     *decimal.Decimal
	handle_status     *int64
	addhandle_status  *int64
	handle_msg        *string
	handle_time       *time.Time
	collect_status    *int64
	addcollect_status *int64
	collect_msg       *string
	collect_time      *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Txn, error)
	predicates        []predicate.Txn
}

var _ ent.Mutation = (*TxnMutation)(nil)

// txnOption allows management of the mutation configuration using functional options.
type txnOption func(*TxnMutation)

// newTxnMutation creates new mutation for the Txn entity.
func newTxnMutation(c config, op Op, opts ...txnOption) *TxnMutation {
	m := &TxnMutation{
		config:        c,
		op:            op,
		typ:           TypeTxn,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTxnID sets the ID field of the mutation.
func withTxnID(id uint64) txnOption {
	return func(m *TxnMutation) {
		var (
			err   error
			once  sync.Once
			value *Txn
		)
		m.oldValue = func(ctx context.Context) (*Txn, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Txn.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTxn sets the old Txn of the mutation.
func withTxn(node *Txn) txnOption {
	return func(m *TxnMutation) {
		m.oldValue = func(context.Context) (*Txn, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TxnMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TxnMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Txn entities.
func (m *TxnMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TxnMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TxnMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Txn.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TxnMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TxnMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Txn entity.
// If the Txn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TxnMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TxnMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TxnMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TxnMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Txn entity.
// If the Txn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TxnMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TxnMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[txn.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TxnMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[txn.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TxnMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, txn.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TxnMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TxnMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Txn entity.
// If the Txn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TxnMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TxnMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[txn.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TxnMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[txn.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TxnMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, txn.FieldDeletedAt)
}

// SetTxID sets the "tx_id" field.
func (m *TxnMutation) SetTxID(s string) {
	m.tx_id = &s
}

// TxID returns the value of the "tx_id" field in the mutation.
func (m *TxnMutation) TxID() (r string, exists bool) {
	v := m.tx_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTxID returns the old "tx_id" field's value of the Txn entity.
// If the Txn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TxnMutation) OldTxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxID: %w", err)
	}
	return oldValue.TxID, nil
}

// ResetTxID resets all changes to the "tx_id" field.
func (m *TxnMutation) ResetTxID() {
	m.tx_id = nil
}

// SetChainID sets the "chain_id" field.
func (m *TxnMutation) SetChainID(u uint64) {
	m.chain_id = &u
	m.addchain_id = nil
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *TxnMutation) ChainID() (r uint64, exists bool) {
	v := m.chain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the Txn entity.
// If the Txn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TxnMutation) OldChainID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// AddChainID adds u to the "chain_id" field.
func (m *TxnMutation) AddChainID(u int64) {
	if m.addchain_id != nil {
		*m.addchain_id += u
	} else {
		m.addchain_id = &u
	}
}

// AddedChainID returns the value that was added to the "chain_id" field in this mutation.
func (m *TxnMutation) AddedChainID() (r int64, exists bool) {
	v := m.addchain_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *TxnMutation) ResetChainID() {
	m.chain_id = nil
	m.addchain_id = nil
}

// SetProductID sets the "product_id" field.
func (m *TxnMutation) SetProductID(i int64) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *TxnMutation) ProductID() (r int64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the Txn entity.
// If the Txn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TxnMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *TxnMutation) AddProductID(i int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *TxnMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductID resets all changes to the "product_id" field.
func (m *TxnMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
}

// SetFromAddress sets the "from_address" field.
func (m *TxnMutation) SetFromAddress(s string) {
	m.from_address = &s
}

// FromAddress returns the value of the "from_address" field in the mutation.
func (m *TxnMutation) FromAddress() (r string, exists bool) {
	v := m.from_address
	if v == nil {
		return
	}
	return *v, true
}

// OldFromAddress returns the old "from_address" field's value of the Txn entity.
// If the Txn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TxnMutation) OldFromAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromAddress: %w", err)
	}
	return oldValue.FromAddress, nil
}

// ResetFromAddress resets all changes to the "from_address" field.
func (m *TxnMutation) ResetFromAddress() {
	m.from_address = nil
}

// SetToAddress sets the "to_address" field.
func (m *TxnMutation) SetToAddress(s string) {
	m.to_address = &s
}

// ToAddress returns the value of the "to_address" field in the mutation.
func (m *TxnMutation) ToAddress() (r string, exists bool) {
	v := m.to_address
	if v == nil {
		return
	}
	return *v, true
}

// OldToAddress returns the old "to_address" field's value of the Txn entity.
// If the Txn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TxnMutation) OldToAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToAddress: %w", err)
	}
	return oldValue.ToAddress, nil
}

// ResetToAddress resets all changes to the "to_address" field.
func (m *TxnMutation) ResetToAddress() {
	m.to_address = nil
}

// SetAmountStr sets the "amount_str" field.
func (m *TxnMutation) SetAmountStr(s string) {
	m.amount_str = &s
}

// AmountStr returns the value of the "amount_str" field in the mutation.
func (m *TxnMutation) AmountStr() (r string, exists bool) {
	v := m.amount_str
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountStr returns the old "amount_str" field's value of the Txn entity.
// If the Txn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TxnMutation) OldAmountStr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountStr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountStr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountStr: %w", err)
	}
	return oldValue.AmountStr, nil
}

// ResetAmountStr resets all changes to the "amount_str" field.
func (m *TxnMutation) ResetAmountStr() {
	m.amount_str = nil
}

// SetAmountRaw sets the "amount_raw" field.
func (m *TxnMutation) SetAmountRaw(d decimal.Decimal) {
	m.amount_raw = &d
	m.addamount_raw = nil
}

// AmountRaw returns the value of the "amount_raw" field in the mutation.
func (m *TxnMutation) AmountRaw() (r decimal.Decimal, exists bool) {
	v := m.amount_raw
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountRaw returns the old "amount_raw" field's value of the Txn entity.
// If the Txn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TxnMutation) OldAmountRaw(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountRaw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountRaw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountRaw: %w", err)
	}
	return oldValue.AmountRaw, nil
}

// AddAmountRaw adds d to the "amount_raw" field.
func (m *TxnMutation) AddAmountRaw(d decimal.Decimal) {
	if m.addamount_raw != nil {
		*m.addamount_raw = m.addamount_raw.Add(d)
	} else {
		m.addamount_raw = &d
	}
}

// AddedAmountRaw returns the value that was added to the "amount_raw" field in this mutation.
func (m *TxnMutation) AddedAmountRaw() (r decimal.Decimal, exists bool) {
	v := m.addamount_raw
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmountRaw resets all changes to the "amount_raw" field.
func (m *TxnMutation) ResetAmountRaw() {
	m.amount_raw = nil
	m.addamount_raw = nil
}

// SetHandleStatus sets the "handle_status" field.
func (m *TxnMutation) SetHandleStatus(i int64) {
	m.handle_status = &i
	m.addhandle_status = nil
}

// HandleStatus returns the value of the "handle_status" field in the mutation.
func (m *TxnMutation) HandleStatus() (r int64, exists bool) {
	v := m.handle_status
	if v == nil {
		return
	}
	return *v, true
}

// OldHandleStatus returns the old "handle_status" field's value of the Txn entity.
// If the Txn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TxnMutation) OldHandleStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandleStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandleStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandleStatus: %w", err)
	}
	return oldValue.HandleStatus, nil
}

// AddHandleStatus adds i to the "handle_status" field.
func (m *TxnMutation) AddHandleStatus(i int64) {
	if m.addhandle_status != nil {
		*m.addhandle_status += i
	} else {
		m.addhandle_status = &i
	}
}

// AddedHandleStatus returns the value that was added to the "handle_status" field in this mutation.
func (m *TxnMutation) AddedHandleStatus() (r int64, exists bool) {
	v := m.addhandle_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetHandleStatus resets all changes to the "handle_status" field.
func (m *TxnMutation) ResetHandleStatus() {
	m.handle_status = nil
	m.addhandle_status = nil
}

// SetHandleMsg sets the "handle_msg" field.
func (m *TxnMutation) SetHandleMsg(s string) {
	m.handle_msg = &s
}

// HandleMsg returns the value of the "handle_msg" field in the mutation.
func (m *TxnMutation) HandleMsg() (r string, exists bool) {
	v := m.handle_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldHandleMsg returns the old "handle_msg" field's value of the Txn entity.
// If the Txn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TxnMutation) OldHandleMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandleMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandleMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandleMsg: %w", err)
	}
	return oldValue.HandleMsg, nil
}

// ClearHandleMsg clears the value of the "handle_msg" field.
func (m *TxnMutation) ClearHandleMsg() {
	m.handle_msg = nil
	m.clearedFields[txn.FieldHandleMsg] = struct{}{}
}

// HandleMsgCleared returns if the "handle_msg" field was cleared in this mutation.
func (m *TxnMutation) HandleMsgCleared() bool {
	_, ok := m.clearedFields[txn.FieldHandleMsg]
	return ok
}

// ResetHandleMsg resets all changes to the "handle_msg" field.
func (m *TxnMutation) ResetHandleMsg() {
	m.handle_msg = nil
	delete(m.clearedFields, txn.FieldHandleMsg)
}

// SetHandleTime sets the "handle_time" field.
func (m *TxnMutation) SetHandleTime(t time.Time) {
	m.handle_time = &t
}

// HandleTime returns the value of the "handle_time" field in the mutation.
func (m *TxnMutation) HandleTime() (r time.Time, exists bool) {
	v := m.handle_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHandleTime returns the old "handle_time" field's value of the Txn entity.
// If the Txn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TxnMutation) OldHandleTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandleTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandleTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandleTime: %w", err)
	}
	return oldValue.HandleTime, nil
}

// ClearHandleTime clears the value of the "handle_time" field.
func (m *TxnMutation) ClearHandleTime() {
	m.handle_time = nil
	m.clearedFields[txn.FieldHandleTime] = struct{}{}
}

// HandleTimeCleared returns if the "handle_time" field was cleared in this mutation.
func (m *TxnMutation) HandleTimeCleared() bool {
	_, ok := m.clearedFields[txn.FieldHandleTime]
	return ok
}

// ResetHandleTime resets all changes to the "handle_time" field.
func (m *TxnMutation) ResetHandleTime() {
	m.handle_time = nil
	delete(m.clearedFields, txn.FieldHandleTime)
}

// SetCollectStatus sets the "collect_status" field.
func (m *TxnMutation) SetCollectStatus(i int64) {
	m.collect_status = &i
	m.addcollect_status = nil
}

// CollectStatus returns the value of the "collect_status" field in the mutation.
func (m *TxnMutation) CollectStatus() (r int64, exists bool) {
	v := m.collect_status
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectStatus returns the old "collect_status" field's value of the Txn entity.
// If the Txn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TxnMutation) OldCollectStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectStatus: %w", err)
	}
	return oldValue.CollectStatus, nil
}

// AddCollectStatus adds i to the "collect_status" field.
func (m *TxnMutation) AddCollectStatus(i int64) {
	if m.addcollect_status != nil {
		*m.addcollect_status += i
	} else {
		m.addcollect_status = &i
	}
}

// AddedCollectStatus returns the value that was added to the "collect_status" field in this mutation.
func (m *TxnMutation) AddedCollectStatus() (r int64, exists bool) {
	v := m.addcollect_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetCollectStatus resets all changes to the "collect_status" field.
func (m *TxnMutation) ResetCollectStatus() {
	m.collect_status = nil
	m.addcollect_status = nil
}

// SetCollectMsg sets the "collect_msg" field.
func (m *TxnMutation) SetCollectMsg(s string) {
	m.collect_msg = &s
}

// CollectMsg returns the value of the "collect_msg" field in the mutation.
func (m *TxnMutation) CollectMsg() (r string, exists bool) {
	v := m.collect_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectMsg returns the old "collect_msg" field's value of the Txn entity.
// If the Txn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TxnMutation) OldCollectMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectMsg: %w", err)
	}
	return oldValue.CollectMsg, nil
}

// ClearCollectMsg clears the value of the "collect_msg" field.
func (m *TxnMutation) ClearCollectMsg() {
	m.collect_msg = nil
	m.clearedFields[txn.FieldCollectMsg] = struct{}{}
}

// CollectMsgCleared returns if the "collect_msg" field was cleared in this mutation.
func (m *TxnMutation) CollectMsgCleared() bool {
	_, ok := m.clearedFields[txn.FieldCollectMsg]
	return ok
}

// ResetCollectMsg resets all changes to the "collect_msg" field.
func (m *TxnMutation) ResetCollectMsg() {
	m.collect_msg = nil
	delete(m.clearedFields, txn.FieldCollectMsg)
}

// SetCollectTime sets the "collect_time" field.
func (m *TxnMutation) SetCollectTime(t time.Time) {
	m.collect_time = &t
}

// CollectTime returns the value of the "collect_time" field in the mutation.
func (m *TxnMutation) CollectTime() (r time.Time, exists bool) {
	v := m.collect_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectTime returns the old "collect_time" field's value of the Txn entity.
// If the Txn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TxnMutation) OldCollectTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectTime: %w", err)
	}
	return oldValue.CollectTime, nil
}

// ClearCollectTime clears the value of the "collect_time" field.
func (m *TxnMutation) ClearCollectTime() {
	m.collect_time = nil
	m.clearedFields[txn.FieldCollectTime] = struct{}{}
}

// CollectTimeCleared returns if the "collect_time" field was cleared in this mutation.
func (m *TxnMutation) CollectTimeCleared() bool {
	_, ok := m.clearedFields[txn.FieldCollectTime]
	return ok
}

// ResetCollectTime resets all changes to the "collect_time" field.
func (m *TxnMutation) ResetCollectTime() {
	m.collect_time = nil
	delete(m.clearedFields, txn.FieldCollectTime)
}

// Where appends a list predicates to the TxnMutation builder.
func (m *TxnMutation) Where(ps ...predicate.Txn) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TxnMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TxnMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Txn, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TxnMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TxnMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Txn).
func (m *TxnMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TxnMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, txn.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, txn.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, txn.FieldDeletedAt)
	}
	if m.tx_id != nil {
		fields = append(fields, txn.FieldTxID)
	}
	if m.chain_id != nil {
		fields = append(fields, txn.FieldChainID)
	}
	if m.product_id != nil {
		fields = append(fields, txn.FieldProductID)
	}
	if m.from_address != nil {
		fields = append(fields, txn.FieldFromAddress)
	}
	if m.to_address != nil {
		fields = append(fields, txn.FieldToAddress)
	}
	if m.amount_str != nil {
		fields = append(fields, txn.FieldAmountStr)
	}
	if m.amount_raw != nil {
		fields = append(fields, txn.FieldAmountRaw)
	}
	if m.handle_status != nil {
		fields = append(fields, txn.FieldHandleStatus)
	}
	if m.handle_msg != nil {
		fields = append(fields, txn.FieldHandleMsg)
	}
	if m.handle_time != nil {
		fields = append(fields, txn.FieldHandleTime)
	}
	if m.collect_status != nil {
		fields = append(fields, txn.FieldCollectStatus)
	}
	if m.collect_msg != nil {
		fields = append(fields, txn.FieldCollectMsg)
	}
	if m.collect_time != nil {
		fields = append(fields, txn.FieldCollectTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TxnMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case txn.FieldCreatedAt:
		return m.CreatedAt()
	case txn.FieldUpdatedAt:
		return m.UpdatedAt()
	case txn.FieldDeletedAt:
		return m.DeletedAt()
	case txn.FieldTxID:
		return m.TxID()
	case txn.FieldChainID:
		return m.ChainID()
	case txn.FieldProductID:
		return m.ProductID()
	case txn.FieldFromAddress:
		return m.FromAddress()
	case txn.FieldToAddress:
		return m.ToAddress()
	case txn.FieldAmountStr:
		return m.AmountStr()
	case txn.FieldAmountRaw:
		return m.AmountRaw()
	case txn.FieldHandleStatus:
		return m.HandleStatus()
	case txn.FieldHandleMsg:
		return m.HandleMsg()
	case txn.FieldHandleTime:
		return m.HandleTime()
	case txn.FieldCollectStatus:
		return m.CollectStatus()
	case txn.FieldCollectMsg:
		return m.CollectMsg()
	case txn.FieldCollectTime:
		return m.CollectTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TxnMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case txn.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case txn.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case txn.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case txn.FieldTxID:
		return m.OldTxID(ctx)
	case txn.FieldChainID:
		return m.OldChainID(ctx)
	case txn.FieldProductID:
		return m.OldProductID(ctx)
	case txn.FieldFromAddress:
		return m.OldFromAddress(ctx)
	case txn.FieldToAddress:
		return m.OldToAddress(ctx)
	case txn.FieldAmountStr:
		return m.OldAmountStr(ctx)
	case txn.FieldAmountRaw:
		return m.OldAmountRaw(ctx)
	case txn.FieldHandleStatus:
		return m.OldHandleStatus(ctx)
	case txn.FieldHandleMsg:
		return m.OldHandleMsg(ctx)
	case txn.FieldHandleTime:
		return m.OldHandleTime(ctx)
	case txn.FieldCollectStatus:
		return m.OldCollectStatus(ctx)
	case txn.FieldCollectMsg:
		return m.OldCollectMsg(ctx)
	case txn.FieldCollectTime:
		return m.OldCollectTime(ctx)
	}
	return nil, fmt.Errorf("unknown Txn field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TxnMutation) SetField(name string, value ent.Value) error {
	switch name {
	case txn.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case txn.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case txn.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case txn.FieldTxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxID(v)
		return nil
	case txn.FieldChainID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	case txn.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case txn.FieldFromAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromAddress(v)
		return nil
	case txn.FieldToAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToAddress(v)
		return nil
	case txn.FieldAmountStr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountStr(v)
		return nil
	case txn.FieldAmountRaw:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountRaw(v)
		return nil
	case txn.FieldHandleStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandleStatus(v)
		return nil
	case txn.FieldHandleMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandleMsg(v)
		return nil
	case txn.FieldHandleTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandleTime(v)
		return nil
	case txn.FieldCollectStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectStatus(v)
		return nil
	case txn.FieldCollectMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectMsg(v)
		return nil
	case txn.FieldCollectTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectTime(v)
		return nil
	}
	return fmt.Errorf("unknown Txn field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TxnMutation) AddedFields() []string {
	var fields []string
	if m.addchain_id != nil {
		fields = append(fields, txn.FieldChainID)
	}
	if m.addproduct_id != nil {
		fields = append(fields, txn.FieldProductID)
	}
	if m.addamount_raw != nil {
		fields = append(fields, txn.FieldAmountRaw)
	}
	if m.addhandle_status != nil {
		fields = append(fields, txn.FieldHandleStatus)
	}
	if m.addcollect_status != nil {
		fields = append(fields, txn.FieldCollectStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TxnMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case txn.FieldChainID:
		return m.AddedChainID()
	case txn.FieldProductID:
		return m.AddedProductID()
	case txn.FieldAmountRaw:
		return m.AddedAmountRaw()
	case txn.FieldHandleStatus:
		return m.AddedHandleStatus()
	case txn.FieldCollectStatus:
		return m.AddedCollectStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TxnMutation) AddField(name string, value ent.Value) error {
	switch name {
	case txn.FieldChainID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChainID(v)
		return nil
	case txn.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case txn.FieldAmountRaw:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmountRaw(v)
		return nil
	case txn.FieldHandleStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHandleStatus(v)
		return nil
	case txn.FieldCollectStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCollectStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Txn numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TxnMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(txn.FieldUpdatedAt) {
		fields = append(fields, txn.FieldUpdatedAt)
	}
	if m.FieldCleared(txn.FieldDeletedAt) {
		fields = append(fields, txn.FieldDeletedAt)
	}
	if m.FieldCleared(txn.FieldHandleMsg) {
		fields = append(fields, txn.FieldHandleMsg)
	}
	if m.FieldCleared(txn.FieldHandleTime) {
		fields = append(fields, txn.FieldHandleTime)
	}
	if m.FieldCleared(txn.FieldCollectMsg) {
		fields = append(fields, txn.FieldCollectMsg)
	}
	if m.FieldCleared(txn.FieldCollectTime) {
		fields = append(fields, txn.FieldCollectTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TxnMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TxnMutation) ClearField(name string) error {
	switch name {
	case txn.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case txn.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case txn.FieldHandleMsg:
		m.ClearHandleMsg()
		return nil
	case txn.FieldHandleTime:
		m.ClearHandleTime()
		return nil
	case txn.FieldCollectMsg:
		m.ClearCollectMsg()
		return nil
	case txn.FieldCollectTime:
		m.ClearCollectTime()
		return nil
	}
	return fmt.Errorf("unknown Txn nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TxnMutation) ResetField(name string) error {
	switch name {
	case txn.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case txn.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case txn.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case txn.FieldTxID:
		m.ResetTxID()
		return nil
	case txn.FieldChainID:
		m.ResetChainID()
		return nil
	case txn.FieldProductID:
		m.ResetProductID()
		return nil
	case txn.FieldFromAddress:
		m.ResetFromAddress()
		return nil
	case txn.FieldToAddress:
		m.ResetToAddress()
		return nil
	case txn.FieldAmountStr:
		m.ResetAmountStr()
		return nil
	case txn.FieldAmountRaw:
		m.ResetAmountRaw()
		return nil
	case txn.FieldHandleStatus:
		m.ResetHandleStatus()
		return nil
	case txn.FieldHandleMsg:
		m.ResetHandleMsg()
		return nil
	case txn.FieldHandleTime:
		m.ResetHandleTime()
		return nil
	case txn.FieldCollectStatus:
		m.ResetCollectStatus()
		return nil
	case txn.FieldCollectMsg:
		m.ResetCollectMsg()
		return nil
	case txn.FieldCollectTime:
		m.ResetCollectTime()
		return nil
	}
	return fmt.Errorf("unknown Txn field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TxnMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TxnMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TxnMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TxnMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TxnMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TxnMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TxnMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Txn unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TxnMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Txn edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	role          *int64
	addrole       *int64
	username      *string
	password      *string
	auth_google   *string
	auth_token    *string
	setting       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uint64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(i int64) {
	m.role = &i
	m.addrole = nil
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r int64, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// AddRole adds i to the "role" field.
func (m *UserMutation) AddRole(i int64) {
	if m.addrole != nil {
		*m.addrole += i
	} else {
		m.addrole = &i
	}
}

// AddedRole returns the value that was added to the "role" field in this mutation.
func (m *UserMutation) AddedRole() (r int64, exists bool) {
	v := m.addrole
	if v == nil {
		return
	}
	return *v, true
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
	m.addrole = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetAuthGoogle sets the "auth_google" field.
func (m *UserMutation) SetAuthGoogle(s string) {
	m.auth_google = &s
}

// AuthGoogle returns the value of the "auth_google" field in the mutation.
func (m *UserMutation) AuthGoogle() (r string, exists bool) {
	v := m.auth_google
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthGoogle returns the old "auth_google" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAuthGoogle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthGoogle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthGoogle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthGoogle: %w", err)
	}
	return oldValue.AuthGoogle, nil
}

// ResetAuthGoogle resets all changes to the "auth_google" field.
func (m *UserMutation) ResetAuthGoogle() {
	m.auth_google = nil
}

// SetAuthToken sets the "auth_token" field.
func (m *UserMutation) SetAuthToken(s string) {
	m.auth_token = &s
}

// AuthToken returns the value of the "auth_token" field in the mutation.
func (m *UserMutation) AuthToken() (r string, exists bool) {
	v := m.auth_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthToken returns the old "auth_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAuthToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthToken: %w", err)
	}
	return oldValue.AuthToken, nil
}

// ResetAuthToken resets all changes to the "auth_token" field.
func (m *UserMutation) ResetAuthToken() {
	m.auth_token = nil
}

// SetSetting sets the "setting" field.
func (m *UserMutation) SetSetting(s string) {
	m.setting = &s
}

// Setting returns the value of the "setting" field in the mutation.
func (m *UserMutation) Setting() (r string, exists bool) {
	v := m.setting
	if v == nil {
		return
	}
	return *v, true
}

// OldSetting returns the old "setting" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSetting(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSetting is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSetting requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSetting: %w", err)
	}
	return oldValue.Setting, nil
}

// ResetSetting resets all changes to the "setting" field.
func (m *UserMutation) ResetSetting() {
	m.setting = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.auth_google != nil {
		fields = append(fields, user.FieldAuthGoogle)
	}
	if m.auth_token != nil {
		fields = append(fields, user.FieldAuthToken)
	}
	if m.setting != nil {
		fields = append(fields, user.FieldSetting)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldRole:
		return m.Role()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldAuthGoogle:
		return m.AuthGoogle()
	case user.FieldAuthToken:
		return m.AuthToken()
	case user.FieldSetting:
		return m.Setting()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldAuthGoogle:
		return m.OldAuthGoogle(ctx)
	case user.FieldAuthToken:
		return m.OldAuthToken(ctx)
	case user.FieldSetting:
		return m.OldSetting(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldRole:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldAuthGoogle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthGoogle(v)
		return nil
	case user.FieldAuthToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthToken(v)
		return nil
	case user.FieldSetting:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSetting(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addrole != nil {
		fields = append(fields, user.FieldRole)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldRole:
		return m.AddedRole()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldRole:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRole(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldCreatedAt) {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldAuthGoogle:
		m.ResetAuthGoogle()
		return nil
	case user.FieldAuthToken:
		m.ResetAuthToken()
		return nil
	case user.FieldSetting:
		m.ResetSetting()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// WithdrawMutation represents an operation that mutates the Withdraw nodes in the graph.
type WithdrawMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	product_id       *int64
	addproduct_id    *int64
	chain_id         *uint64
	addchain_id      *int64
	to_address       *string
	amount_str       *string
	amount_raw       *decimal.Decimal
	addamount_raw    *decimal.Decimal
	serial_id        *string
	tx_hash          *string
	handle_status    *int64
	addhandle_status *int64
	handle_msg       *string
	handle_time      *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Withdraw, error)
	predicates       []predicate.Withdraw
}

var _ ent.Mutation = (*WithdrawMutation)(nil)

// withdrawOption allows management of the mutation configuration using functional options.
type withdrawOption func(*WithdrawMutation)

// newWithdrawMutation creates new mutation for the Withdraw entity.
func newWithdrawMutation(c config, op Op, opts ...withdrawOption) *WithdrawMutation {
	m := &WithdrawMutation{
		config:        c,
		op:            op,
		typ:           TypeWithdraw,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWithdrawID sets the ID field of the mutation.
func withWithdrawID(id uint64) withdrawOption {
	return func(m *WithdrawMutation) {
		var (
			err   error
			once  sync.Once
			value *Withdraw
		)
		m.oldValue = func(ctx context.Context) (*Withdraw, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Withdraw.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWithdraw sets the old Withdraw of the mutation.
func withWithdraw(node *Withdraw) withdrawOption {
	return func(m *WithdrawMutation) {
		m.oldValue = func(context.Context) (*Withdraw, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WithdrawMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WithdrawMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Withdraw entities.
func (m *WithdrawMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WithdrawMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WithdrawMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Withdraw.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WithdrawMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WithdrawMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WithdrawMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WithdrawMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WithdrawMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *WithdrawMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[withdraw.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *WithdrawMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[withdraw.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WithdrawMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, withdraw.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WithdrawMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WithdrawMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *WithdrawMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[withdraw.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *WithdrawMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[withdraw.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WithdrawMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, withdraw.FieldDeletedAt)
}

// SetProductID sets the "product_id" field.
func (m *WithdrawMutation) SetProductID(i int64) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *WithdrawMutation) ProductID() (r int64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *WithdrawMutation) AddProductID(i int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *WithdrawMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductID resets all changes to the "product_id" field.
func (m *WithdrawMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
}

// SetChainID sets the "chain_id" field.
func (m *WithdrawMutation) SetChainID(u uint64) {
	m.chain_id = &u
	m.addchain_id = nil
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *WithdrawMutation) ChainID() (r uint64, exists bool) {
	v := m.chain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldChainID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// AddChainID adds u to the "chain_id" field.
func (m *WithdrawMutation) AddChainID(u int64) {
	if m.addchain_id != nil {
		*m.addchain_id += u
	} else {
		m.addchain_id = &u
	}
}

// AddedChainID returns the value that was added to the "chain_id" field in this mutation.
func (m *WithdrawMutation) AddedChainID() (r int64, exists bool) {
	v := m.addchain_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *WithdrawMutation) ResetChainID() {
	m.chain_id = nil
	m.addchain_id = nil
}

// SetToAddress sets the "to_address" field.
func (m *WithdrawMutation) SetToAddress(s string) {
	m.to_address = &s
}

// ToAddress returns the value of the "to_address" field in the mutation.
func (m *WithdrawMutation) ToAddress() (r string, exists bool) {
	v := m.to_address
	if v == nil {
		return
	}
	return *v, true
}

// OldToAddress returns the old "to_address" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldToAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToAddress: %w", err)
	}
	return oldValue.ToAddress, nil
}

// ResetToAddress resets all changes to the "to_address" field.
func (m *WithdrawMutation) ResetToAddress() {
	m.to_address = nil
}

// SetAmountStr sets the "amount_str" field.
func (m *WithdrawMutation) SetAmountStr(s string) {
	m.amount_str = &s
}

// AmountStr returns the value of the "amount_str" field in the mutation.
func (m *WithdrawMutation) AmountStr() (r string, exists bool) {
	v := m.amount_str
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountStr returns the old "amount_str" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldAmountStr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountStr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountStr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountStr: %w", err)
	}
	return oldValue.AmountStr, nil
}

// ResetAmountStr resets all changes to the "amount_str" field.
func (m *WithdrawMutation) ResetAmountStr() {
	m.amount_str = nil
}

// SetAmountRaw sets the "amount_raw" field.
func (m *WithdrawMutation) SetAmountRaw(d decimal.Decimal) {
	m.amount_raw = &d
	m.addamount_raw = nil
}

// AmountRaw returns the value of the "amount_raw" field in the mutation.
func (m *WithdrawMutation) AmountRaw() (r decimal.Decimal, exists bool) {
	v := m.amount_raw
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountRaw returns the old "amount_raw" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldAmountRaw(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountRaw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountRaw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountRaw: %w", err)
	}
	return oldValue.AmountRaw, nil
}

// AddAmountRaw adds d to the "amount_raw" field.
func (m *WithdrawMutation) AddAmountRaw(d decimal.Decimal) {
	if m.addamount_raw != nil {
		*m.addamount_raw = m.addamount_raw.Add(d)
	} else {
		m.addamount_raw = &d
	}
}

// AddedAmountRaw returns the value that was added to the "amount_raw" field in this mutation.
func (m *WithdrawMutation) AddedAmountRaw() (r decimal.Decimal, exists bool) {
	v := m.addamount_raw
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmountRaw resets all changes to the "amount_raw" field.
func (m *WithdrawMutation) ResetAmountRaw() {
	m.amount_raw = nil
	m.addamount_raw = nil
}

// SetSerialID sets the "serial_id" field.
func (m *WithdrawMutation) SetSerialID(s string) {
	m.serial_id = &s
}

// SerialID returns the value of the "serial_id" field in the mutation.
func (m *WithdrawMutation) SerialID() (r string, exists bool) {
	v := m.serial_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialID returns the old "serial_id" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldSerialID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialID: %w", err)
	}
	return oldValue.SerialID, nil
}

// ResetSerialID resets all changes to the "serial_id" field.
func (m *WithdrawMutation) ResetSerialID() {
	m.serial_id = nil
}

// SetTxHash sets the "tx_hash" field.
func (m *WithdrawMutation) SetTxHash(s string) {
	m.tx_hash = &s
}

// TxHash returns the value of the "tx_hash" field in the mutation.
func (m *WithdrawMutation) TxHash() (r string, exists bool) {
	v := m.tx_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTxHash returns the old "tx_hash" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldTxHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxHash: %w", err)
	}
	return oldValue.TxHash, nil
}

// ClearTxHash clears the value of the "tx_hash" field.
func (m *WithdrawMutation) ClearTxHash() {
	m.tx_hash = nil
	m.clearedFields[withdraw.FieldTxHash] = struct{}{}
}

// TxHashCleared returns if the "tx_hash" field was cleared in this mutation.
func (m *WithdrawMutation) TxHashCleared() bool {
	_, ok := m.clearedFields[withdraw.FieldTxHash]
	return ok
}

// ResetTxHash resets all changes to the "tx_hash" field.
func (m *WithdrawMutation) ResetTxHash() {
	m.tx_hash = nil
	delete(m.clearedFields, withdraw.FieldTxHash)
}

// SetHandleStatus sets the "handle_status" field.
func (m *WithdrawMutation) SetHandleStatus(i int64) {
	m.handle_status = &i
	m.addhandle_status = nil
}

// HandleStatus returns the value of the "handle_status" field in the mutation.
func (m *WithdrawMutation) HandleStatus() (r int64, exists bool) {
	v := m.handle_status
	if v == nil {
		return
	}
	return *v, true
}

// OldHandleStatus returns the old "handle_status" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldHandleStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandleStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandleStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandleStatus: %w", err)
	}
	return oldValue.HandleStatus, nil
}

// AddHandleStatus adds i to the "handle_status" field.
func (m *WithdrawMutation) AddHandleStatus(i int64) {
	if m.addhandle_status != nil {
		*m.addhandle_status += i
	} else {
		m.addhandle_status = &i
	}
}

// AddedHandleStatus returns the value that was added to the "handle_status" field in this mutation.
func (m *WithdrawMutation) AddedHandleStatus() (r int64, exists bool) {
	v := m.addhandle_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetHandleStatus resets all changes to the "handle_status" field.
func (m *WithdrawMutation) ResetHandleStatus() {
	m.handle_status = nil
	m.addhandle_status = nil
}

// SetHandleMsg sets the "handle_msg" field.
func (m *WithdrawMutation) SetHandleMsg(s string) {
	m.handle_msg = &s
}

// HandleMsg returns the value of the "handle_msg" field in the mutation.
func (m *WithdrawMutation) HandleMsg() (r string, exists bool) {
	v := m.handle_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldHandleMsg returns the old "handle_msg" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldHandleMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandleMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandleMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandleMsg: %w", err)
	}
	return oldValue.HandleMsg, nil
}

// ClearHandleMsg clears the value of the "handle_msg" field.
func (m *WithdrawMutation) ClearHandleMsg() {
	m.handle_msg = nil
	m.clearedFields[withdraw.FieldHandleMsg] = struct{}{}
}

// HandleMsgCleared returns if the "handle_msg" field was cleared in this mutation.
func (m *WithdrawMutation) HandleMsgCleared() bool {
	_, ok := m.clearedFields[withdraw.FieldHandleMsg]
	return ok
}

// ResetHandleMsg resets all changes to the "handle_msg" field.
func (m *WithdrawMutation) ResetHandleMsg() {
	m.handle_msg = nil
	delete(m.clearedFields, withdraw.FieldHandleMsg)
}

// SetHandleTime sets the "handle_time" field.
func (m *WithdrawMutation) SetHandleTime(t time.Time) {
	m.handle_time = &t
}

// HandleTime returns the value of the "handle_time" field in the mutation.
func (m *WithdrawMutation) HandleTime() (r time.Time, exists bool) {
	v := m.handle_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHandleTime returns the old "handle_time" field's value of the Withdraw entity.
// If the Withdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WithdrawMutation) OldHandleTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandleTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandleTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandleTime: %w", err)
	}
	return oldValue.HandleTime, nil
}

// ClearHandleTime clears the value of the "handle_time" field.
func (m *WithdrawMutation) ClearHandleTime() {
	m.handle_time = nil
	m.clearedFields[withdraw.FieldHandleTime] = struct{}{}
}

// HandleTimeCleared returns if the "handle_time" field was cleared in this mutation.
func (m *WithdrawMutation) HandleTimeCleared() bool {
	_, ok := m.clearedFields[withdraw.FieldHandleTime]
	return ok
}

// ResetHandleTime resets all changes to the "handle_time" field.
func (m *WithdrawMutation) ResetHandleTime() {
	m.handle_time = nil
	delete(m.clearedFields, withdraw.FieldHandleTime)
}

// Where appends a list predicates to the WithdrawMutation builder.
func (m *WithdrawMutation) Where(ps ...predicate.Withdraw) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WithdrawMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WithdrawMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Withdraw, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WithdrawMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WithdrawMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Withdraw).
func (m *WithdrawMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WithdrawMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, withdraw.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, withdraw.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, withdraw.FieldDeletedAt)
	}
	if m.product_id != nil {
		fields = append(fields, withdraw.FieldProductID)
	}
	if m.chain_id != nil {
		fields = append(fields, withdraw.FieldChainID)
	}
	if m.to_address != nil {
		fields = append(fields, withdraw.FieldToAddress)
	}
	if m.amount_str != nil {
		fields = append(fields, withdraw.FieldAmountStr)
	}
	if m.amount_raw != nil {
		fields = append(fields, withdraw.FieldAmountRaw)
	}
	if m.serial_id != nil {
		fields = append(fields, withdraw.FieldSerialID)
	}
	if m.tx_hash != nil {
		fields = append(fields, withdraw.FieldTxHash)
	}
	if m.handle_status != nil {
		fields = append(fields, withdraw.FieldHandleStatus)
	}
	if m.handle_msg != nil {
		fields = append(fields, withdraw.FieldHandleMsg)
	}
	if m.handle_time != nil {
		fields = append(fields, withdraw.FieldHandleTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WithdrawMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case withdraw.FieldCreatedAt:
		return m.CreatedAt()
	case withdraw.FieldUpdatedAt:
		return m.UpdatedAt()
	case withdraw.FieldDeletedAt:
		return m.DeletedAt()
	case withdraw.FieldProductID:
		return m.ProductID()
	case withdraw.FieldChainID:
		return m.ChainID()
	case withdraw.FieldToAddress:
		return m.ToAddress()
	case withdraw.FieldAmountStr:
		return m.AmountStr()
	case withdraw.FieldAmountRaw:
		return m.AmountRaw()
	case withdraw.FieldSerialID:
		return m.SerialID()
	case withdraw.FieldTxHash:
		return m.TxHash()
	case withdraw.FieldHandleStatus:
		return m.HandleStatus()
	case withdraw.FieldHandleMsg:
		return m.HandleMsg()
	case withdraw.FieldHandleTime:
		return m.HandleTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WithdrawMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case withdraw.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case withdraw.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case withdraw.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case withdraw.FieldProductID:
		return m.OldProductID(ctx)
	case withdraw.FieldChainID:
		return m.OldChainID(ctx)
	case withdraw.FieldToAddress:
		return m.OldToAddress(ctx)
	case withdraw.FieldAmountStr:
		return m.OldAmountStr(ctx)
	case withdraw.FieldAmountRaw:
		return m.OldAmountRaw(ctx)
	case withdraw.FieldSerialID:
		return m.OldSerialID(ctx)
	case withdraw.FieldTxHash:
		return m.OldTxHash(ctx)
	case withdraw.FieldHandleStatus:
		return m.OldHandleStatus(ctx)
	case withdraw.FieldHandleMsg:
		return m.OldHandleMsg(ctx)
	case withdraw.FieldHandleTime:
		return m.OldHandleTime(ctx)
	}
	return nil, fmt.Errorf("unknown Withdraw field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WithdrawMutation) SetField(name string, value ent.Value) error {
	switch name {
	case withdraw.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case withdraw.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case withdraw.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case withdraw.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case withdraw.FieldChainID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	case withdraw.FieldToAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToAddress(v)
		return nil
	case withdraw.FieldAmountStr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountStr(v)
		return nil
	case withdraw.FieldAmountRaw:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountRaw(v)
		return nil
	case withdraw.FieldSerialID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialID(v)
		return nil
	case withdraw.FieldTxHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxHash(v)
		return nil
	case withdraw.FieldHandleStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandleStatus(v)
		return nil
	case withdraw.FieldHandleMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandleMsg(v)
		return nil
	case withdraw.FieldHandleTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandleTime(v)
		return nil
	}
	return fmt.Errorf("unknown Withdraw field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WithdrawMutation) AddedFields() []string {
	var fields []string
	if m.addproduct_id != nil {
		fields = append(fields, withdraw.FieldProductID)
	}
	if m.addchain_id != nil {
		fields = append(fields, withdraw.FieldChainID)
	}
	if m.addamount_raw != nil {
		fields = append(fields, withdraw.FieldAmountRaw)
	}
	if m.addhandle_status != nil {
		fields = append(fields, withdraw.FieldHandleStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WithdrawMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case withdraw.FieldProductID:
		return m.AddedProductID()
	case withdraw.FieldChainID:
		return m.AddedChainID()
	case withdraw.FieldAmountRaw:
		return m.AddedAmountRaw()
	case withdraw.FieldHandleStatus:
		return m.AddedHandleStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WithdrawMutation) AddField(name string, value ent.Value) error {
	switch name {
	case withdraw.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case withdraw.FieldChainID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChainID(v)
		return nil
	case withdraw.FieldAmountRaw:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmountRaw(v)
		return nil
	case withdraw.FieldHandleStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHandleStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Withdraw numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WithdrawMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(withdraw.FieldUpdatedAt) {
		fields = append(fields, withdraw.FieldUpdatedAt)
	}
	if m.FieldCleared(withdraw.FieldDeletedAt) {
		fields = append(fields, withdraw.FieldDeletedAt)
	}
	if m.FieldCleared(withdraw.FieldTxHash) {
		fields = append(fields, withdraw.FieldTxHash)
	}
	if m.FieldCleared(withdraw.FieldHandleMsg) {
		fields = append(fields, withdraw.FieldHandleMsg)
	}
	if m.FieldCleared(withdraw.FieldHandleTime) {
		fields = append(fields, withdraw.FieldHandleTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WithdrawMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WithdrawMutation) ClearField(name string) error {
	switch name {
	case withdraw.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case withdraw.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case withdraw.FieldTxHash:
		m.ClearTxHash()
		return nil
	case withdraw.FieldHandleMsg:
		m.ClearHandleMsg()
		return nil
	case withdraw.FieldHandleTime:
		m.ClearHandleTime()
		return nil
	}
	return fmt.Errorf("unknown Withdraw nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WithdrawMutation) ResetField(name string) error {
	switch name {
	case withdraw.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case withdraw.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case withdraw.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case withdraw.FieldProductID:
		m.ResetProductID()
		return nil
	case withdraw.FieldChainID:
		m.ResetChainID()
		return nil
	case withdraw.FieldToAddress:
		m.ResetToAddress()
		return nil
	case withdraw.FieldAmountStr:
		m.ResetAmountStr()
		return nil
	case withdraw.FieldAmountRaw:
		m.ResetAmountRaw()
		return nil
	case withdraw.FieldSerialID:
		m.ResetSerialID()
		return nil
	case withdraw.FieldTxHash:
		m.ResetTxHash()
		return nil
	case withdraw.FieldHandleStatus:
		m.ResetHandleStatus()
		return nil
	case withdraw.FieldHandleMsg:
		m.ResetHandleMsg()
		return nil
	case withdraw.FieldHandleTime:
		m.ResetHandleTime()
		return nil
	}
	return fmt.Errorf("unknown Withdraw field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WithdrawMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WithdrawMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WithdrawMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WithdrawMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WithdrawMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WithdrawMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WithdrawMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Withdraw unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WithdrawMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Withdraw edge %s", name)
}
