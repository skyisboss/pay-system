// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/shopspring/decimal"
	"github.com/skyisboss/pay-system/ent/blockchain"
	"github.com/skyisboss/pay-system/ent/schema"
)

// Blockchain is the model entity for the Blockchain schema.
type Blockchain struct {
	config `json:"-"`
	// ID of the ent.
	ID uint64 `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// DeletedAt holds the value of the "deleted_at" field.
	DeletedAt time.Time `json:"deleted_at,omitempty"`
	// Chain holds the value of the "chain" field.
	Chain string `json:"chain,omitempty"`
	// Types holds the value of the "types" field.
	Types string `json:"types,omitempty"`
	// Symbol holds the value of the "symbol" field.
	Symbol string `json:"symbol,omitempty"`
	// Decimals holds the value of the "decimals" field.
	Decimals int64 `json:"decimals,omitempty"`
	// Status holds the value of the "status" field.
	Status int64 `json:"status,omitempty"`
	// TokenAddress holds the value of the "token_address" field.
	TokenAddress string `json:"token_address,omitempty"`
	// TokenAbi holds the value of the "token_abi" field.
	TokenAbi string `json:"token_abi,omitempty"`
	// ColdAddress holds the value of the "cold_address" field.
	ColdAddress string `json:"cold_address,omitempty"`
	// HotAddress holds the value of the "hot_address" field.
	HotAddress string `json:"hot_address,omitempty"`
	// ScanBlockNum holds the value of the "scan_block_num" field.
	ScanBlockNum int64 `json:"scan_block_num,omitempty"`
	// MinFreeNum holds the value of the "min_free_num" field.
	MinFreeNum int64 `json:"min_free_num,omitempty"`
	// MinConfirmNum holds the value of the "min_confirm_num" field.
	MinConfirmNum int64 `json:"min_confirm_num,omitempty"`
	// WithdrawFee holds the value of the "withdraw_fee" field.
	WithdrawFee float64 `json:"withdraw_fee,omitempty"`
	// WithdrawFeeType holds the value of the "withdraw_fee_type" field.
	WithdrawFeeType int64 `json:"withdraw_fee_type,omitempty"`
	// MinDeposit holds the value of the "min_deposit" field.
	MinDeposit decimal.Decimal `json:"min_deposit,omitempty"`
	// MinWithdraw holds the value of the "min_withdraw" field.
	MinWithdraw decimal.Decimal `json:"min_withdraw,omitempty"`
	// MinCollect holds the value of the "min_collect" field.
	MinCollect decimal.Decimal `json:"min_collect,omitempty"`
	// GasPrice holds the value of the "gas_price" field.
	GasPrice     schema.GasPrice `json:"gas_price,omitempty"`
	selectValues sql.SelectValues
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Blockchain) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case blockchain.FieldGasPrice:
			values[i] = new([]byte)
		case blockchain.FieldMinDeposit, blockchain.FieldMinWithdraw, blockchain.FieldMinCollect:
			values[i] = new(decimal.Decimal)
		case blockchain.FieldWithdrawFee:
			values[i] = new(sql.NullFloat64)
		case blockchain.FieldID, blockchain.FieldDecimals, blockchain.FieldStatus, blockchain.FieldScanBlockNum, blockchain.FieldMinFreeNum, blockchain.FieldMinConfirmNum, blockchain.FieldWithdrawFeeType:
			values[i] = new(sql.NullInt64)
		case blockchain.FieldChain, blockchain.FieldTypes, blockchain.FieldSymbol, blockchain.FieldTokenAddress, blockchain.FieldTokenAbi, blockchain.FieldColdAddress, blockchain.FieldHotAddress:
			values[i] = new(sql.NullString)
		case blockchain.FieldCreatedAt, blockchain.FieldUpdatedAt, blockchain.FieldDeletedAt:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Blockchain fields.
func (b *Blockchain) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case blockchain.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			b.ID = uint64(value.Int64)
		case blockchain.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				b.CreatedAt = value.Time
			}
		case blockchain.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				b.UpdatedAt = value.Time
			}
		case blockchain.FieldDeletedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_at", values[i])
			} else if value.Valid {
				b.DeletedAt = value.Time
			}
		case blockchain.FieldChain:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field chain", values[i])
			} else if value.Valid {
				b.Chain = value.String
			}
		case blockchain.FieldTypes:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field types", values[i])
			} else if value.Valid {
				b.Types = value.String
			}
		case blockchain.FieldSymbol:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field symbol", values[i])
			} else if value.Valid {
				b.Symbol = value.String
			}
		case blockchain.FieldDecimals:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field decimals", values[i])
			} else if value.Valid {
				b.Decimals = value.Int64
			}
		case blockchain.FieldStatus:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				b.Status = value.Int64
			}
		case blockchain.FieldTokenAddress:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field token_address", values[i])
			} else if value.Valid {
				b.TokenAddress = value.String
			}
		case blockchain.FieldTokenAbi:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field token_abi", values[i])
			} else if value.Valid {
				b.TokenAbi = value.String
			}
		case blockchain.FieldColdAddress:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field cold_address", values[i])
			} else if value.Valid {
				b.ColdAddress = value.String
			}
		case blockchain.FieldHotAddress:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field hot_address", values[i])
			} else if value.Valid {
				b.HotAddress = value.String
			}
		case blockchain.FieldScanBlockNum:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field scan_block_num", values[i])
			} else if value.Valid {
				b.ScanBlockNum = value.Int64
			}
		case blockchain.FieldMinFreeNum:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field min_free_num", values[i])
			} else if value.Valid {
				b.MinFreeNum = value.Int64
			}
		case blockchain.FieldMinConfirmNum:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field min_confirm_num", values[i])
			} else if value.Valid {
				b.MinConfirmNum = value.Int64
			}
		case blockchain.FieldWithdrawFee:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field withdraw_fee", values[i])
			} else if value.Valid {
				b.WithdrawFee = value.Float64
			}
		case blockchain.FieldWithdrawFeeType:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field withdraw_fee_type", values[i])
			} else if value.Valid {
				b.WithdrawFeeType = value.Int64
			}
		case blockchain.FieldMinDeposit:
			if value, ok := values[i].(*decimal.Decimal); !ok {
				return fmt.Errorf("unexpected type %T for field min_deposit", values[i])
			} else if value != nil {
				b.MinDeposit = *value
			}
		case blockchain.FieldMinWithdraw:
			if value, ok := values[i].(*decimal.Decimal); !ok {
				return fmt.Errorf("unexpected type %T for field min_withdraw", values[i])
			} else if value != nil {
				b.MinWithdraw = *value
			}
		case blockchain.FieldMinCollect:
			if value, ok := values[i].(*decimal.Decimal); !ok {
				return fmt.Errorf("unexpected type %T for field min_collect", values[i])
			} else if value != nil {
				b.MinCollect = *value
			}
		case blockchain.FieldGasPrice:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field gas_price", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &b.GasPrice); err != nil {
					return fmt.Errorf("unmarshal field gas_price: %w", err)
				}
			}
		default:
			b.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Blockchain.
// This includes values selected through modifiers, order, etc.
func (b *Blockchain) Value(name string) (ent.Value, error) {
	return b.selectValues.Get(name)
}

// Update returns a builder for updating this Blockchain.
// Note that you need to call Blockchain.Unwrap() before calling this method if this Blockchain
// was returned from a transaction, and the transaction was committed or rolled back.
func (b *Blockchain) Update() *BlockchainUpdateOne {
	return NewBlockchainClient(b.config).UpdateOne(b)
}

// Unwrap unwraps the Blockchain entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (b *Blockchain) Unwrap() *Blockchain {
	_tx, ok := b.config.driver.(*txDriver)
	if !ok {
		panic("ent: Blockchain is not a transactional entity")
	}
	b.config.driver = _tx.drv
	return b
}

// String implements the fmt.Stringer.
func (b *Blockchain) String() string {
	var builder strings.Builder
	builder.WriteString("Blockchain(")
	builder.WriteString(fmt.Sprintf("id=%v, ", b.ID))
	builder.WriteString("created_at=")
	builder.WriteString(b.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(b.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("deleted_at=")
	builder.WriteString(b.DeletedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("chain=")
	builder.WriteString(b.Chain)
	builder.WriteString(", ")
	builder.WriteString("types=")
	builder.WriteString(b.Types)
	builder.WriteString(", ")
	builder.WriteString("symbol=")
	builder.WriteString(b.Symbol)
	builder.WriteString(", ")
	builder.WriteString("decimals=")
	builder.WriteString(fmt.Sprintf("%v", b.Decimals))
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(fmt.Sprintf("%v", b.Status))
	builder.WriteString(", ")
	builder.WriteString("token_address=")
	builder.WriteString(b.TokenAddress)
	builder.WriteString(", ")
	builder.WriteString("token_abi=")
	builder.WriteString(b.TokenAbi)
	builder.WriteString(", ")
	builder.WriteString("cold_address=")
	builder.WriteString(b.ColdAddress)
	builder.WriteString(", ")
	builder.WriteString("hot_address=")
	builder.WriteString(b.HotAddress)
	builder.WriteString(", ")
	builder.WriteString("scan_block_num=")
	builder.WriteString(fmt.Sprintf("%v", b.ScanBlockNum))
	builder.WriteString(", ")
	builder.WriteString("min_free_num=")
	builder.WriteString(fmt.Sprintf("%v", b.MinFreeNum))
	builder.WriteString(", ")
	builder.WriteString("min_confirm_num=")
	builder.WriteString(fmt.Sprintf("%v", b.MinConfirmNum))
	builder.WriteString(", ")
	builder.WriteString("withdraw_fee=")
	builder.WriteString(fmt.Sprintf("%v", b.WithdrawFee))
	builder.WriteString(", ")
	builder.WriteString("withdraw_fee_type=")
	builder.WriteString(fmt.Sprintf("%v", b.WithdrawFeeType))
	builder.WriteString(", ")
	builder.WriteString("min_deposit=")
	builder.WriteString(fmt.Sprintf("%v", b.MinDeposit))
	builder.WriteString(", ")
	builder.WriteString("min_withdraw=")
	builder.WriteString(fmt.Sprintf("%v", b.MinWithdraw))
	builder.WriteString(", ")
	builder.WriteString("min_collect=")
	builder.WriteString(fmt.Sprintf("%v", b.MinCollect))
	builder.WriteString(", ")
	builder.WriteString("gas_price=")
	builder.WriteString(fmt.Sprintf("%v", b.GasPrice))
	builder.WriteByte(')')
	return builder.String()
}

// Blockchains is a parsable slice of Blockchain.
type Blockchains []*Blockchain
